{"version":3,"file":"sentry-CV5hkgyg.js","sources":["../../../node_modules/.pnpm/@sentry+core@10.40.0/node_modules/@sentry/core/build/esm/debug-build.js","../../../node_modules/.pnpm/@sentry+core@10.40.0/node_modules/@sentry/core/build/esm/utils/worldwide.js","../../../node_modules/.pnpm/@sentry+core@10.40.0/node_modules/@sentry/core/build/esm/utils/version.js","../../../node_modules/.pnpm/@sentry+core@10.40.0/node_modules/@sentry/core/build/esm/carrier.js","../../../node_modules/.pnpm/@sentry+core@10.40.0/node_modules/@sentry/core/build/esm/utils/debug-logger.js","../../../node_modules/.pnpm/@sentry+core@10.40.0/node_modules/@sentry/core/build/esm/utils/is.js","../../../node_modules/.pnpm/@sentry+core@10.40.0/node_modules/@sentry/core/build/esm/utils/object.js","../../../node_modules/.pnpm/@sentry+core@10.40.0/node_modules/@sentry/core/build/esm/utils/randomSafeContext.js","../../../node_modules/.pnpm/@sentry+core@10.40.0/node_modules/@sentry/core/build/esm/utils/string.js","../../../node_modules/.pnpm/@sentry+core@10.40.0/node_modules/@sentry/core/build/esm/utils/misc.js","../../../node_modules/.pnpm/@sentry+core@10.40.0/node_modules/@sentry/core/build/esm/utils/time.js","../../../node_modules/.pnpm/@sentry+core@10.40.0/node_modules/@sentry/core/build/esm/session.js","../../../node_modules/.pnpm/@sentry+core@10.40.0/node_modules/@sentry/core/build/esm/utils/merge.js","../../../node_modules/.pnpm/@sentry+core@10.40.0/node_modules/@sentry/core/build/esm/utils/propagationContext.js","../../../node_modules/.pnpm/@sentry+core@10.40.0/node_modules/@sentry/core/build/esm/utils/spanOnScope.js","../../../node_modules/.pnpm/@sentry+core@10.40.0/node_modules/@sentry/core/build/esm/scope.js","../../../node_modules/.pnpm/@sentry+core@10.40.0/node_modules/@sentry/core/build/esm/defaultScopes.js","../../../node_modules/.pnpm/@sentry+core@10.40.0/node_modules/@sentry/core/build/esm/asyncContext/stackStrategy.js","../../../node_modules/.pnpm/@sentry+core@10.40.0/node_modules/@sentry/core/build/esm/asyncContext/index.js","../../../node_modules/.pnpm/@sentry+core@10.40.0/node_modules/@sentry/core/build/esm/currentScopes.js","../../../node_modules/.pnpm/@sentry+core@10.40.0/node_modules/@sentry/core/build/esm/utils/prepareEvent.js","../../../node_modules/.pnpm/@sentry+core@10.40.0/node_modules/@sentry/core/build/esm/exports.js","../../../node_modules/.pnpm/react@19.2.1/node_modules/react/cjs/react.production.js","../../../node_modules/.pnpm/react@19.2.1/node_modules/react/index.js"],"sourcesContent":["/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nconst DEBUG_BUILD = (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__);\n\nexport { DEBUG_BUILD };\n//# sourceMappingURL=debug-build.js.map\n","/** Internal global with common properties and Sentry extensions  */\n\n/** Get's the global object for the current JavaScript runtime */\nconst GLOBAL_OBJ = globalThis ;\n\nexport { GLOBAL_OBJ };\n//# sourceMappingURL=worldwide.js.map\n","// This is a magic string replaced by rollup\n\nconst SDK_VERSION = \"10.40.0\" ;\n\nexport { SDK_VERSION };\n//# sourceMappingURL=version.js.map\n","import { SDK_VERSION } from './utils/version.js';\nimport { GLOBAL_OBJ } from './utils/worldwide.js';\n\n/**\n * An object that contains globally accessible properties and maintains a scope stack.\n * @hidden\n */\n\n/**\n * Returns the global shim registry.\n *\n * FIXME: This function is problematic, because despite always returning a valid Carrier,\n * it has an optional `__SENTRY__` property, which then in turn requires us to always perform an unnecessary check\n * at the call-site. We always access the carrier through this function, so we can guarantee that `__SENTRY__` is there.\n **/\nfunction getMainCarrier() {\n  // This ensures a Sentry carrier exists\n  getSentryCarrier(GLOBAL_OBJ);\n  return GLOBAL_OBJ;\n}\n\n/** Will either get the existing sentry carrier, or create a new one. */\nfunction getSentryCarrier(carrier) {\n  const __SENTRY__ = (carrier.__SENTRY__ = carrier.__SENTRY__ || {});\n\n  // For now: First SDK that sets the .version property wins\n  __SENTRY__.version = __SENTRY__.version || SDK_VERSION;\n\n  // Intentionally populating and returning the version of \"this\" SDK instance\n  // rather than what's set in .version so that \"this\" SDK always gets its carrier\n  return (__SENTRY__[SDK_VERSION] = __SENTRY__[SDK_VERSION] || {});\n}\n\n/**\n * Returns a global singleton contained in the global `__SENTRY__[]` object.\n *\n * If the singleton doesn't already exist in `__SENTRY__`, it will be created using the given factory\n * function and added to the `__SENTRY__` object.\n *\n * @param name name of the global singleton on __SENTRY__\n * @param creator creator Factory function to create the singleton if it doesn't already exist on `__SENTRY__`\n * @param obj (Optional) The global object on which to look for `__SENTRY__`, if not `GLOBAL_OBJ`'s return value\n * @returns the singleton\n */\nfunction getGlobalSingleton(\n  name,\n  creator,\n  obj = GLOBAL_OBJ,\n) {\n  const __SENTRY__ = (obj.__SENTRY__ = obj.__SENTRY__ || {});\n  const carrier = (__SENTRY__[SDK_VERSION] = __SENTRY__[SDK_VERSION] || {});\n  // Note: We do not want to set `carrier.version` here, as this may be called before any `init` is called, e.g. for the default scopes\n  return carrier[name] || (carrier[name] = creator());\n}\n\nexport { getGlobalSingleton, getMainCarrier, getSentryCarrier };\n//# sourceMappingURL=carrier.js.map\n","import { getGlobalSingleton } from '../carrier.js';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { GLOBAL_OBJ } from './worldwide.js';\n\nconst CONSOLE_LEVELS = [\n  'debug',\n  'info',\n  'warn',\n  'error',\n  'log',\n  'assert',\n  'trace',\n] ;\n\n/** Prefix for logging strings */\nconst PREFIX = 'Sentry Logger ';\n\n/** This may be mutated by the console instrumentation. */\nconst originalConsoleMethods\n\n = {};\n\n/**\n * Temporarily disable sentry console instrumentations.\n *\n * @param callback The function to run against the original `console` messages\n * @returns The results of the callback\n */\nfunction consoleSandbox(callback) {\n  if (!('console' in GLOBAL_OBJ)) {\n    return callback();\n  }\n\n  const console = GLOBAL_OBJ.console;\n  const wrappedFuncs = {};\n\n  const wrappedLevels = Object.keys(originalConsoleMethods) ;\n\n  // Restore all wrapped console methods\n  wrappedLevels.forEach(level => {\n    const originalConsoleMethod = originalConsoleMethods[level];\n    wrappedFuncs[level] = console[level] ;\n    console[level] = originalConsoleMethod ;\n  });\n\n  try {\n    return callback();\n  } finally {\n    // Revert restoration to wrapped state\n    wrappedLevels.forEach(level => {\n      console[level] = wrappedFuncs[level] ;\n    });\n  }\n}\n\nfunction enable() {\n  _getLoggerSettings().enabled = true;\n}\n\nfunction disable() {\n  _getLoggerSettings().enabled = false;\n}\n\nfunction isEnabled() {\n  return _getLoggerSettings().enabled;\n}\n\nfunction log(...args) {\n  _maybeLog('log', ...args);\n}\n\nfunction warn(...args) {\n  _maybeLog('warn', ...args);\n}\n\nfunction error(...args) {\n  _maybeLog('error', ...args);\n}\n\nfunction _maybeLog(level, ...args) {\n  if (!DEBUG_BUILD) {\n    return;\n  }\n\n  if (isEnabled()) {\n    consoleSandbox(() => {\n      GLOBAL_OBJ.console[level](`${PREFIX}[${level}]:`, ...args);\n    });\n  }\n}\n\nfunction _getLoggerSettings() {\n  if (!DEBUG_BUILD) {\n    return { enabled: false };\n  }\n\n  return getGlobalSingleton('loggerSettings', () => ({ enabled: false }));\n}\n\n/**\n * This is a logger singleton which either logs things or no-ops if logging is not enabled.\n */\nconst debug = {\n  /** Enable logging. */\n  enable,\n  /** Disable logging. */\n  disable,\n  /** Check if logging is enabled. */\n  isEnabled,\n  /** Log a message. */\n  log,\n  /** Log a warning. */\n  warn,\n  /** Log an error. */\n  error,\n} ;\n\nexport { CONSOLE_LEVELS, consoleSandbox, debug, originalConsoleMethods };\n//# sourceMappingURL=debug-logger.js.map\n","// eslint-disable-next-line @typescript-eslint/unbound-method\nconst objectToString = Object.prototype.toString;\n\n/**\n * Checks whether given value's type is one of a few Error or Error-like\n * {@link isError}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isError(wat) {\n  switch (objectToString.call(wat)) {\n    case '[object Error]':\n    case '[object Exception]':\n    case '[object DOMException]':\n    case '[object WebAssembly.Exception]':\n      return true;\n    default:\n      return isInstanceOf(wat, Error);\n  }\n}\n/**\n * Checks whether given value is an instance of the given built-in class.\n *\n * @param wat The value to be checked\n * @param className\n * @returns A boolean representing the result.\n */\nfunction isBuiltin(wat, className) {\n  return objectToString.call(wat) === `[object ${className}]`;\n}\n\n/**\n * Checks whether given value's type is ErrorEvent\n * {@link isErrorEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isErrorEvent(wat) {\n  return isBuiltin(wat, 'ErrorEvent');\n}\n\n/**\n * Checks whether given value's type is DOMError\n * {@link isDOMError}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isDOMError(wat) {\n  return isBuiltin(wat, 'DOMError');\n}\n\n/**\n * Checks whether given value's type is DOMException\n * {@link isDOMException}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isDOMException(wat) {\n  return isBuiltin(wat, 'DOMException');\n}\n\n/**\n * Checks whether given value's type is a string\n * {@link isString}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isString(wat) {\n  return isBuiltin(wat, 'String');\n}\n\n/**\n * Checks whether given string is parameterized\n * {@link isParameterizedString}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isParameterizedString(wat) {\n  return (\n    typeof wat === 'object' &&\n    wat !== null &&\n    '__sentry_template_string__' in wat &&\n    '__sentry_template_values__' in wat\n  );\n}\n\n/**\n * Checks whether given value is a primitive (undefined, null, number, boolean, string, bigint, symbol)\n * {@link isPrimitive}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isPrimitive(wat) {\n  return wat === null || isParameterizedString(wat) || (typeof wat !== 'object' && typeof wat !== 'function');\n}\n\n/**\n * Checks whether given value's type is an object literal, or a class instance.\n * {@link isPlainObject}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isPlainObject(wat) {\n  return isBuiltin(wat, 'Object');\n}\n\n/**\n * Checks whether given value's type is an Event instance\n * {@link isEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isEvent(wat) {\n  return typeof Event !== 'undefined' && isInstanceOf(wat, Event);\n}\n\n/**\n * Checks whether given value's type is an Element instance\n * {@link isElement}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isElement(wat) {\n  return typeof Element !== 'undefined' && isInstanceOf(wat, Element);\n}\n\n/**\n * Checks whether given value's type is an regexp\n * {@link isRegExp}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isRegExp(wat) {\n  return isBuiltin(wat, 'RegExp');\n}\n\n/**\n * Checks whether given value has a then function.\n * @param wat A value to be checked.\n */\nfunction isThenable(wat) {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  return Boolean(wat?.then && typeof wat.then === 'function');\n}\n\n/**\n * Checks whether given value's type is a SyntheticEvent\n * {@link isSyntheticEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isSyntheticEvent(wat) {\n  return isPlainObject(wat) && 'nativeEvent' in wat && 'preventDefault' in wat && 'stopPropagation' in wat;\n}\n\n/**\n * Checks whether given value's type is an instance of provided constructor.\n * {@link isInstanceOf}.\n *\n * @param wat A value to be checked.\n * @param base A constructor to be used in a check.\n * @returns A boolean representing the result.\n */\n// TODO: fix in v11, convert any to unknown\n// export function isInstanceOf<T>(wat: unknown, base: { new (...args: any[]): T }): wat is T {\nfunction isInstanceOf(wat, base) {\n  try {\n    return wat instanceof base;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Checks whether given value's type is a Vue ViewModel or a VNode.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nfunction isVueViewModel(wat) {\n  // Not using Object.prototype.toString because in Vue 3 it would read the instance's Symbol(Symbol.toStringTag) property.\n  // We also need to check for __v_isVNode because Vue 3 component render instances have an internal __v_isVNode property.\n  return !!(\n    typeof wat === 'object' &&\n    wat !== null &&\n    ((wat ).__isVue || (wat )._isVue || (wat ).__v_isVNode)\n  );\n}\n\n/**\n * Checks whether the given parameter is a Standard Web API Request instance.\n *\n * Returns false if Request is not available in the current runtime.\n */\nfunction isRequest(request) {\n  return typeof Request !== 'undefined' && isInstanceOf(request, Request);\n}\n\nexport { isDOMError, isDOMException, isElement, isError, isErrorEvent, isEvent, isInstanceOf, isParameterizedString, isPlainObject, isPrimitive, isRegExp, isRequest, isString, isSyntheticEvent, isThenable, isVueViewModel };\n//# sourceMappingURL=is.js.map\n","import { DEBUG_BUILD } from '../debug-build.js';\nimport { htmlTreeAsString } from './browser.js';\nimport { debug } from './debug-logger.js';\nimport { isError, isEvent, isInstanceOf, isPrimitive, isElement } from './is.js';\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/**\n * Replace a method in an object with a wrapped version of itself.\n *\n * If the method on the passed object is not a function, the wrapper will not be applied.\n *\n * @param source An object that contains a method to be wrapped.\n * @param name The name of the method to be wrapped.\n * @param replacementFactory A higher-order function that takes the original version of the given method and returns a\n * wrapped version. Note: The function returned by `replacementFactory` needs to be a non-arrow function, in order to\n * preserve the correct value of `this`, and the original method must be called using `origMethod.call(this, <other\n * args>)` or `origMethod.apply(this, [<other args>])` (rather than being called directly), again to preserve `this`.\n * @returns void\n */\nfunction fill(source, name, replacementFactory) {\n  if (!(name in source)) {\n    return;\n  }\n\n  // explicitly casting to unknown because we don't know the type of the method initially at all\n  const original = source[name] ;\n\n  if (typeof original !== 'function') {\n    return;\n  }\n\n  const wrapped = replacementFactory(original) ;\n\n  // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work\n  // otherwise it'll throw \"TypeError: Object.defineProperties called on non-object\"\n  if (typeof wrapped === 'function') {\n    markFunctionWrapped(wrapped, original);\n  }\n\n  try {\n    source[name] = wrapped;\n  } catch {\n    DEBUG_BUILD && debug.log(`Failed to replace method \"${name}\" in object`, source);\n  }\n}\n\n/**\n * Defines a non-enumerable property on the given object.\n *\n * @param obj The object on which to set the property\n * @param name The name of the property to be set\n * @param value The value to which to set the property\n */\nfunction addNonEnumerableProperty(obj, name, value) {\n  try {\n    Object.defineProperty(obj, name, {\n      // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it\n      value: value,\n      writable: true,\n      configurable: true,\n    });\n  } catch {\n    DEBUG_BUILD && debug.log(`Failed to add non-enumerable property \"${name}\" to object`, obj);\n  }\n}\n\n/**\n * Remembers the original function on the wrapped function and\n * patches up the prototype.\n *\n * @param wrapped the wrapper function\n * @param original the original function that gets wrapped\n */\nfunction markFunctionWrapped(wrapped, original) {\n  try {\n    const proto = original.prototype || {};\n    wrapped.prototype = original.prototype = proto;\n    addNonEnumerableProperty(wrapped, '__sentry_original__', original);\n  } catch {} // eslint-disable-line no-empty\n}\n\n/**\n * This extracts the original function if available.  See\n * `markFunctionWrapped` for more information.\n *\n * @param func the function to unwrap\n * @returns the unwrapped version of the function if available.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction getOriginalFunction(func) {\n  return func.__sentry_original__;\n}\n\n/**\n * Transforms any `Error` or `Event` into a plain object with all of their enumerable properties, and some of their\n * non-enumerable properties attached.\n *\n * @param value Initial source that we have to transform in order for it to be usable by the serializer\n * @returns An Event or Error turned into an object - or the value argument itself, when value is neither an Event nor\n *  an Error.\n */\nfunction convertToPlainObject(value)\n\n {\n  if (isError(value)) {\n    return {\n      message: value.message,\n      name: value.name,\n      stack: value.stack,\n      ...getOwnProperties(value),\n    };\n  } else if (isEvent(value)) {\n    const newObj\n\n = {\n      type: value.type,\n      target: serializeEventTarget(value.target),\n      currentTarget: serializeEventTarget(value.currentTarget),\n      ...getOwnProperties(value),\n    };\n\n    if (typeof CustomEvent !== 'undefined' && isInstanceOf(value, CustomEvent)) {\n      newObj.detail = value.detail;\n    }\n\n    return newObj;\n  } else {\n    return value;\n  }\n}\n\n/** Creates a string representation of the target of an `Event` object */\nfunction serializeEventTarget(target) {\n  try {\n    return isElement(target) ? htmlTreeAsString(target) : Object.prototype.toString.call(target);\n  } catch {\n    return '<unknown>';\n  }\n}\n\n/** Filters out all but an object's own properties */\nfunction getOwnProperties(obj) {\n  if (typeof obj === 'object' && obj !== null) {\n    const extractedProps = {};\n    for (const property in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, property)) {\n        extractedProps[property] = (obj )[property];\n      }\n    }\n    return extractedProps;\n  } else {\n    return {};\n  }\n}\n\n/**\n * Given any captured exception, extract its keys and create a sorted\n * and truncated list that will be used inside the event message.\n * eg. `Non-error exception captured with keys: foo, bar, baz`\n */\nfunction extractExceptionKeysForMessage(exception) {\n  const keys = Object.keys(convertToPlainObject(exception));\n  keys.sort();\n\n  return !keys[0] ? '[object has no keys]' : keys.join(', ');\n}\n\n/**\n * Given any object, return a new object having removed all fields whose value was `undefined`.\n * Works recursively on objects and arrays.\n *\n * Attention: This function keeps circular references in the returned object.\n *\n * @deprecated This function is no longer used by the SDK and will be removed in a future major version.\n */\nfunction dropUndefinedKeys(inputValue) {\n  // This map keeps track of what already visited nodes map to.\n  // Our Set - based memoBuilder doesn't work here because we want to the output object to have the same circular\n  // references as the input object.\n  const memoizationMap = new Map();\n\n  // This function just proxies `_dropUndefinedKeys` to keep the `memoBuilder` out of this function's API\n  return _dropUndefinedKeys(inputValue, memoizationMap);\n}\n\nfunction _dropUndefinedKeys(inputValue, memoizationMap) {\n  // Early return for primitive values\n  if (inputValue === null || typeof inputValue !== 'object') {\n    return inputValue;\n  }\n\n  // Check memo map first for all object types\n  const memoVal = memoizationMap.get(inputValue);\n  if (memoVal !== undefined) {\n    return memoVal ;\n  }\n\n  // handle arrays\n  if (Array.isArray(inputValue)) {\n    const returnValue = [];\n    // Store mapping to handle circular references\n    memoizationMap.set(inputValue, returnValue);\n\n    inputValue.forEach(value => {\n      returnValue.push(_dropUndefinedKeys(value, memoizationMap));\n    });\n\n    return returnValue ;\n  }\n\n  if (isPojo(inputValue)) {\n    const returnValue = {};\n    // Store mapping to handle circular references\n    memoizationMap.set(inputValue, returnValue);\n\n    const keys = Object.keys(inputValue);\n\n    keys.forEach(key => {\n      const val = inputValue[key];\n      if (val !== undefined) {\n        returnValue[key] = _dropUndefinedKeys(val, memoizationMap);\n      }\n    });\n\n    return returnValue ;\n  }\n\n  // For other object types, return as is\n  return inputValue;\n}\n\nfunction isPojo(input) {\n  // Plain objects have Object as constructor or no constructor\n  const constructor = (input ).constructor;\n  return constructor === Object || constructor === undefined;\n}\n\n/**\n * Ensure that something is an object.\n *\n * Turns `undefined` and `null` into `String`s and all other primitives into instances of their respective wrapper\n * classes (String, Boolean, Number, etc.). Acts as the identity function on non-primitives.\n *\n * @param wat The subject of the objectification\n * @returns A version of `wat` which can safely be used with `Object` class methods\n */\nfunction objectify(wat) {\n  let objectified;\n  switch (true) {\n    // this will catch both undefined and null\n    case wat == undefined:\n      objectified = new String(wat);\n      break;\n\n    // Though symbols and bigints do have wrapper classes (`Symbol` and `BigInt`, respectively), for whatever reason\n    // those classes don't have constructors which can be used with the `new` keyword. We therefore need to cast each as\n    // an object in order to wrap it.\n    case typeof wat === 'symbol' || typeof wat === 'bigint':\n      objectified = Object(wat);\n      break;\n\n    // this will catch the remaining primitives: `String`, `Number`, and `Boolean`\n    case isPrimitive(wat):\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      objectified = new (wat ).constructor(wat);\n      break;\n\n    // by process of elimination, at this point we know that `wat` must already be an object\n    default:\n      objectified = wat;\n      break;\n  }\n  return objectified;\n}\n\nexport { addNonEnumerableProperty, convertToPlainObject, dropUndefinedKeys, extractExceptionKeysForMessage, fill, getOriginalFunction, markFunctionWrapped, objectify };\n//# sourceMappingURL=object.js.map\n","import { GLOBAL_OBJ } from './worldwide.js';\n\n// undefined = not yet resolved, null = no runner found, function = runner found\nlet RESOLVED_RUNNER;\n\n/**\n * Simple wrapper that allows SDKs to *secretly* set context wrapper to generate safe random IDs in cache components contexts\n */\nfunction withRandomSafeContext(cb) {\n  // Skips future symbol lookups if we've already resolved (or attempted to resolve) the runner once\n  if (RESOLVED_RUNNER !== undefined) {\n    return RESOLVED_RUNNER ? RESOLVED_RUNNER(cb) : cb();\n  }\n\n  const sym = Symbol.for('__SENTRY_SAFE_RANDOM_ID_WRAPPER__');\n  const globalWithSymbol = GLOBAL_OBJ;\n\n  if (sym in globalWithSymbol && typeof globalWithSymbol[sym] === 'function') {\n    RESOLVED_RUNNER = globalWithSymbol[sym];\n    return RESOLVED_RUNNER(cb);\n  }\n\n  RESOLVED_RUNNER = null;\n  return cb();\n}\n\n/**\n * Identical to Math.random() but wrapped in withRandomSafeContext\n * to ensure safe random number generation in certain contexts (e.g., Next.js Cache Components).\n */\nfunction safeMathRandom() {\n  return withRandomSafeContext(() => Math.random());\n}\n\n/**\n * Identical to Date.now() but wrapped in withRandomSafeContext\n * to ensure safe time value generation in certain contexts (e.g., Next.js Cache Components).\n */\nfunction safeDateNow() {\n  return withRandomSafeContext(() => Date.now());\n}\n\nexport { safeDateNow, safeMathRandom, withRandomSafeContext };\n//# sourceMappingURL=randomSafeContext.js.map\n","import { isString, isRegExp, isVueViewModel } from './is.js';\nimport { getVueInternalName } from './stacktrace.js';\n\n/**\n * Truncates given string to the maximum characters count\n *\n * @param str An object that contains serializable values\n * @param max Maximum number of characters in truncated string (0 = unlimited)\n * @returns string Encoded\n */\nfunction truncate(str, max = 0) {\n  if (typeof str !== 'string' || max === 0) {\n    return str;\n  }\n  return str.length <= max ? str : `${str.slice(0, max)}...`;\n}\n\n/**\n * This is basically just `trim_line` from\n * https://github.com/getsentry/sentry/blob/master/src/sentry/lang/javascript/processor.py#L67\n *\n * @param str An object that contains serializable values\n * @param max Maximum number of characters in truncated string\n * @returns string Encoded\n */\nfunction snipLine(line, colno) {\n  let newLine = line;\n  const lineLength = newLine.length;\n  if (lineLength <= 150) {\n    return newLine;\n  }\n  if (colno > lineLength) {\n    // eslint-disable-next-line no-param-reassign\n    colno = lineLength;\n  }\n\n  let start = Math.max(colno - 60, 0);\n  if (start < 5) {\n    start = 0;\n  }\n\n  let end = Math.min(start + 140, lineLength);\n  if (end > lineLength - 5) {\n    end = lineLength;\n  }\n  if (end === lineLength) {\n    start = Math.max(end - 140, 0);\n  }\n\n  newLine = newLine.slice(start, end);\n  if (start > 0) {\n    newLine = `'{snip} ${newLine}`;\n  }\n  if (end < lineLength) {\n    newLine += ' {snip}';\n  }\n\n  return newLine;\n}\n\n/**\n * Join values in array\n * @param input array of values to be joined together\n * @param delimiter string to be placed in-between values\n * @returns Joined values\n */\nfunction safeJoin(input, delimiter) {\n  if (!Array.isArray(input)) {\n    return '';\n  }\n\n  const output = [];\n  // eslint-disable-next-line @typescript-eslint/prefer-for-of\n  for (let i = 0; i < input.length; i++) {\n    const value = input[i];\n    try {\n      // This is a hack to fix a Vue3-specific bug that causes an infinite loop of\n      // console warnings. This happens when a Vue template is rendered with\n      // an undeclared variable, which we try to stringify, ultimately causing\n      // Vue to issue another warning which repeats indefinitely.\n      // see: https://github.com/getsentry/sentry-javascript/pull/8981\n      if (isVueViewModel(value)) {\n        output.push(getVueInternalName(value));\n      } else {\n        output.push(String(value));\n      }\n    } catch {\n      output.push('[value cannot be serialized]');\n    }\n  }\n\n  return output.join(delimiter);\n}\n\n/**\n * Checks if the given value matches a regex or string\n *\n * @param value The string to test\n * @param pattern Either a regex or a string against which `value` will be matched\n * @param requireExactStringMatch If true, `value` must match `pattern` exactly. If false, `value` will match\n * `pattern` if it contains `pattern`. Only applies to string-type patterns.\n */\nfunction isMatchingPattern(\n  value,\n  pattern,\n  requireExactStringMatch = false,\n) {\n  if (!isString(value)) {\n    return false;\n  }\n\n  if (isRegExp(pattern)) {\n    return pattern.test(value);\n  }\n  if (isString(pattern)) {\n    return requireExactStringMatch ? value === pattern : value.includes(pattern);\n  }\n\n  return false;\n}\n\n/**\n * Test the given string against an array of strings and regexes. By default, string matching is done on a\n * substring-inclusion basis rather than a strict equality basis\n *\n * @param testString The string to test\n * @param patterns The patterns against which to test the string\n * @param requireExactStringMatch If true, `testString` must match one of the given string patterns exactly in order to\n * count. If false, `testString` will match a string pattern if it contains that pattern.\n * @returns\n */\nfunction stringMatchesSomePattern(\n  testString,\n  patterns = [],\n  requireExactStringMatch = false,\n) {\n  return patterns.some(pattern => isMatchingPattern(testString, pattern, requireExactStringMatch));\n}\n\nexport { isMatchingPattern, safeJoin, snipLine, stringMatchesSomePattern, truncate };\n//# sourceMappingURL=string.js.map\n","import { addNonEnumerableProperty } from './object.js';\nimport { withRandomSafeContext, safeMathRandom } from './randomSafeContext.js';\nimport { snipLine } from './string.js';\nimport { GLOBAL_OBJ } from './worldwide.js';\n\nfunction getCrypto() {\n  const gbl = GLOBAL_OBJ ;\n  return gbl.crypto || gbl.msCrypto;\n}\n\nlet emptyUuid;\n\nfunction getRandomByte() {\n  return safeMathRandom() * 16;\n}\n\n/**\n * UUID4 generator\n * @param crypto Object that provides the crypto API.\n * @returns string Generated UUID4.\n */\nfunction uuid4(crypto = getCrypto()) {\n  try {\n    if (crypto?.randomUUID) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return withRandomSafeContext(() => crypto.randomUUID()).replace(/-/g, '');\n    }\n  } catch {\n    // some runtimes can crash invoking crypto\n    // https://github.com/getsentry/sentry-javascript/issues/8935\n  }\n\n  if (!emptyUuid) {\n    // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523\n    // Concatenating the following numbers as strings results in '10000000100040008000100000000000'\n    emptyUuid = ([1e7] ) + 1e3 + 4e3 + 8e3 + 1e11;\n  }\n\n  return emptyUuid.replace(/[018]/g, c =>\n    // eslint-disable-next-line no-bitwise\n    ((c ) ^ ((getRandomByte() & 15) >> ((c ) / 4))).toString(16),\n  );\n}\n\nfunction getFirstException(event) {\n  return event.exception?.values?.[0];\n}\n\n/**\n * Extracts either message or type+value from an event that can be used for user-facing logs\n * @returns event's description\n */\nfunction getEventDescription(event) {\n  const { message, event_id: eventId } = event;\n  if (message) {\n    return message;\n  }\n\n  const firstException = getFirstException(event);\n  if (firstException) {\n    if (firstException.type && firstException.value) {\n      return `${firstException.type}: ${firstException.value}`;\n    }\n    return firstException.type || firstException.value || eventId || '<unknown>';\n  }\n  return eventId || '<unknown>';\n}\n\n/**\n * Adds exception values, type and value to an synthetic Exception.\n * @param event The event to modify.\n * @param value Value of the exception.\n * @param type Type of the exception.\n * @hidden\n */\nfunction addExceptionTypeValue(event, value, type) {\n  const exception = (event.exception = event.exception || {});\n  const values = (exception.values = exception.values || []);\n  const firstException = (values[0] = values[0] || {});\n  if (!firstException.value) {\n    firstException.value = value || '';\n  }\n  if (!firstException.type) {\n    firstException.type = type || 'Error';\n  }\n}\n\n/**\n * Adds exception mechanism data to a given event. Uses defaults if the second parameter is not passed.\n *\n * @param event The event to modify.\n * @param newMechanism Mechanism data to add to the event.\n * @hidden\n */\nfunction addExceptionMechanism(event, newMechanism) {\n  const firstException = getFirstException(event);\n  if (!firstException) {\n    return;\n  }\n\n  const defaultMechanism = { type: 'generic', handled: true };\n  const currentMechanism = firstException.mechanism;\n  firstException.mechanism = { ...defaultMechanism, ...currentMechanism, ...newMechanism };\n\n  if (newMechanism && 'data' in newMechanism) {\n    const mergedData = { ...currentMechanism?.data, ...newMechanism.data };\n    firstException.mechanism.data = mergedData;\n  }\n}\n\n// https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\nconst SEMVER_REGEXP =\n  /^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$/;\n\n/**\n * Represents Semantic Versioning object\n */\n\nfunction _parseInt(input) {\n  return parseInt(input || '', 10);\n}\n\n/**\n * Parses input into a SemVer interface\n * @param input string representation of a semver version\n */\nfunction parseSemver(input) {\n  const match = input.match(SEMVER_REGEXP) || [];\n  const major = _parseInt(match[1]);\n  const minor = _parseInt(match[2]);\n  const patch = _parseInt(match[3]);\n  return {\n    buildmetadata: match[5],\n    major: isNaN(major) ? undefined : major,\n    minor: isNaN(minor) ? undefined : minor,\n    patch: isNaN(patch) ? undefined : patch,\n    prerelease: match[4],\n  };\n}\n\n/**\n * This function adds context (pre/post/line) lines to the provided frame\n *\n * @param lines string[] containing all lines\n * @param frame StackFrame that will be mutated\n * @param linesOfContext number of context lines we want to add pre/post\n */\nfunction addContextToFrame(lines, frame, linesOfContext = 5) {\n  // When there is no line number in the frame, attaching context is nonsensical and will even break grouping\n  if (frame.lineno === undefined) {\n    return;\n  }\n\n  const maxLines = lines.length;\n  const sourceLine = Math.max(Math.min(maxLines - 1, frame.lineno - 1), 0);\n\n  frame.pre_context = lines\n    .slice(Math.max(0, sourceLine - linesOfContext), sourceLine)\n    .map((line) => snipLine(line, 0));\n\n  // We guard here to ensure this is not larger than the existing number of lines\n  const lineIndex = Math.min(maxLines - 1, sourceLine);\n\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  frame.context_line = snipLine(lines[lineIndex], frame.colno || 0);\n\n  frame.post_context = lines\n    .slice(Math.min(sourceLine + 1, maxLines), sourceLine + 1 + linesOfContext)\n    .map((line) => snipLine(line, 0));\n}\n\n/**\n * Checks whether or not we've already captured the given exception (note: not an identical exception - the very object\n * in question), and marks it captured if not.\n *\n * This is useful because it's possible for an error to get captured by more than one mechanism. After we intercept and\n * record an error, we rethrow it (assuming we've intercepted it before it's reached the top-level global handlers), so\n * that we don't interfere with whatever effects the error might have had were the SDK not there. At that point, because\n * the error has been rethrown, it's possible for it to bubble up to some other code we've instrumented. If it's not\n * caught after that, it will bubble all the way up to the global handlers (which of course we also instrument). This\n * function helps us ensure that even if we encounter the same error more than once, we only record it the first time we\n * see it.\n *\n * Note: It will ignore primitives (always return `false` and not mark them as seen), as properties can't be set on\n * them. {@link: Object.objectify} can be used on exceptions to convert any that are primitives into their equivalent\n * object wrapper forms so that this check will always work. However, because we need to flag the exact object which\n * will get rethrown, and because that rethrowing happens outside of the event processing pipeline, the objectification\n * must be done before the exception captured.\n *\n * @param A thrown exception to check or flag as having been seen\n * @returns `true` if the exception has already been captured, `false` if not (with the side effect of marking it seen)\n */\nfunction checkOrSetAlreadyCaught(exception) {\n  if (isAlreadyCaptured(exception)) {\n    return true;\n  }\n\n  try {\n    // set it this way rather than by assignment so that it's not ennumerable and therefore isn't recorded by the\n    // `ExtraErrorData` integration\n    addNonEnumerableProperty(exception , '__sentry_captured__', true);\n  } catch {\n    // `exception` is a primitive, so we can't mark it seen\n  }\n\n  return false;\n}\n\n/**\n * Checks whether we've already captured the given exception (note: not an identical exception - the very object).\n * It is considered already captured if it has the `__sentry_captured__` property set to `true`.\n *\n * @internal Only considered for internal usage\n */\nfunction isAlreadyCaptured(exception) {\n  try {\n    return (exception ).__sentry_captured__;\n  } catch {} // eslint-disable-line no-empty\n}\n\nexport { addContextToFrame, addExceptionMechanism, addExceptionTypeValue, checkOrSetAlreadyCaught, getEventDescription, isAlreadyCaptured, parseSemver, uuid4 };\n//# sourceMappingURL=misc.js.map\n","import { safeDateNow, withRandomSafeContext } from './randomSafeContext.js';\nimport { GLOBAL_OBJ } from './worldwide.js';\n\nconst ONE_SECOND_IN_MS = 1000;\n\n/**\n * A partial definition of the [Performance Web API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Performance}\n * for accessing a high-resolution monotonic clock.\n */\n\n/**\n * Returns a timestamp in seconds since the UNIX epoch using the Date API.\n */\nfunction dateTimestampInSeconds() {\n  return safeDateNow() / ONE_SECOND_IN_MS;\n}\n\n/**\n * Returns a wrapper around the native Performance API browser implementation, or undefined for browsers that do not\n * support the API.\n *\n * Wrapping the native API works around differences in behavior from different browsers.\n */\nfunction createUnixTimestampInSecondsFunc() {\n  const { performance } = GLOBAL_OBJ ;\n  // Some browser and environments don't have a performance or timeOrigin, so we fallback to\n  // using Date.now() to compute the starting time.\n  if (!performance?.now || !performance.timeOrigin) {\n    return dateTimestampInSeconds;\n  }\n\n  const timeOrigin = performance.timeOrigin;\n\n  // performance.now() is a monotonic clock, which means it starts at 0 when the process begins. To get the current\n  // wall clock time (actual UNIX timestamp), we need to add the starting time origin and the current time elapsed.\n  //\n  // TODO: This does not account for the case where the monotonic clock that powers performance.now() drifts from the\n  // wall clock time, which causes the returned timestamp to be inaccurate. We should investigate how to detect and\n  // correct for this.\n  // See: https://github.com/getsentry/sentry-javascript/issues/2590\n  // See: https://github.com/mdn/content/issues/4713\n  // See: https://dev.to/noamr/when-a-millisecond-is-not-a-millisecond-3h6\n  return () => {\n    return (timeOrigin + withRandomSafeContext(() => performance.now())) / ONE_SECOND_IN_MS;\n  };\n}\n\nlet _cachedTimestampInSeconds;\n\n/**\n * Returns a timestamp in seconds since the UNIX epoch using either the Performance or Date APIs, depending on the\n * availability of the Performance API.\n *\n * BUG: Note that because of how browsers implement the Performance API, the clock might stop when the computer is\n * asleep. This creates a skew between `dateTimestampInSeconds` and `timestampInSeconds`. The\n * skew can grow to arbitrary amounts like days, weeks or months.\n * See https://github.com/getsentry/sentry-javascript/issues/2590.\n */\nfunction timestampInSeconds() {\n  // We store this in a closure so that we don't have to create a new function every time this is called.\n  const func = _cachedTimestampInSeconds ?? (_cachedTimestampInSeconds = createUnixTimestampInSecondsFunc());\n  return func();\n}\n\n/**\n * Cached result of getBrowserTimeOrigin.\n */\nlet cachedTimeOrigin = null;\n\n/**\n * Gets the time origin and the mode used to determine it.\n *\n * Unfortunately browsers may report an inaccurate time origin data, through either performance.timeOrigin or\n * performance.timing.navigationStart, which results in poor results in performance data. We only treat time origin\n * data as reliable if they are within a reasonable threshold of the current time.\n *\n * TODO: move to `@sentry/browser-utils` package.\n */\nfunction getBrowserTimeOrigin() {\n  const { performance } = GLOBAL_OBJ ;\n  if (!performance?.now) {\n    return undefined;\n  }\n\n  const threshold = 300000; // 5 minutes in milliseconds\n  const performanceNow = withRandomSafeContext(() => performance.now());\n  const dateNow = safeDateNow();\n\n  const timeOrigin = performance.timeOrigin;\n  if (typeof timeOrigin === 'number') {\n    const timeOriginDelta = Math.abs(timeOrigin + performanceNow - dateNow);\n    if (timeOriginDelta < threshold) {\n      return timeOrigin;\n    }\n  }\n\n  // TODO: Remove all code related to `performance.timing.navigationStart` once we drop support for Safari 14.\n  // `performance.timeSince` is available in Safari 15.\n  // see: https://caniuse.com/mdn-api_performance_timeorigin\n\n  // While performance.timing.navigationStart is deprecated in favor of performance.timeOrigin, performance.timeOrigin\n  // is not as widely supported. Namely, performance.timeOrigin is undefined in Safari as of writing.\n  // Also as of writing, performance.timing is not available in Web Workers in mainstream browsers, so it is not always\n  // a valid fallback. In the absence of an initial time provided by the browser, fallback to the current time from the\n  // Date API.\n  // eslint-disable-next-line deprecation/deprecation\n  const navigationStart = performance.timing?.navigationStart;\n  if (typeof navigationStart === 'number') {\n    const navigationStartDelta = Math.abs(navigationStart + performanceNow - dateNow);\n    if (navigationStartDelta < threshold) {\n      return navigationStart;\n    }\n  }\n\n  // Either both timeOrigin and navigationStart are skewed or neither is available, fallback to subtracting\n  // `performance.now()` from `Date.now()`.\n  return dateNow - performanceNow;\n}\n\n/**\n * The number of milliseconds since the UNIX epoch. This value is only usable in a browser, and only when the\n * performance API is available.\n */\nfunction browserPerformanceTimeOrigin() {\n  if (cachedTimeOrigin === null) {\n    cachedTimeOrigin = getBrowserTimeOrigin();\n  }\n\n  return cachedTimeOrigin;\n}\n\nexport { browserPerformanceTimeOrigin, dateTimestampInSeconds, timestampInSeconds };\n//# sourceMappingURL=time.js.map\n","import { uuid4 } from './utils/misc.js';\nimport { timestampInSeconds } from './utils/time.js';\n\n/**\n * Creates a new `Session` object by setting certain default parameters. If optional @param context\n * is passed, the passed properties are applied to the session object.\n *\n * @param context (optional) additional properties to be applied to the returned session object\n *\n * @returns a new `Session` object\n */\nfunction makeSession(context) {\n  // Both timestamp and started are in seconds since the UNIX epoch.\n  const startingTime = timestampInSeconds();\n\n  const session = {\n    sid: uuid4(),\n    init: true,\n    timestamp: startingTime,\n    started: startingTime,\n    duration: 0,\n    status: 'ok',\n    errors: 0,\n    ignoreDuration: false,\n    toJSON: () => sessionToJSON(session),\n  };\n\n  if (context) {\n    updateSession(session, context);\n  }\n\n  return session;\n}\n\n/**\n * Updates a session object with the properties passed in the context.\n *\n * Note that this function mutates the passed object and returns void.\n * (Had to do this instead of returning a new and updated session because closing and sending a session\n * makes an update to the session after it was passed to the sending logic.\n * @see Client.captureSession )\n *\n * @param session the `Session` to update\n * @param context the `SessionContext` holding the properties that should be updated in @param session\n */\n// eslint-disable-next-line complexity\nfunction updateSession(session, context = {}) {\n  if (context.user) {\n    if (!session.ipAddress && context.user.ip_address) {\n      session.ipAddress = context.user.ip_address;\n    }\n\n    if (!session.did && !context.did) {\n      session.did = context.user.id || context.user.email || context.user.username;\n    }\n  }\n\n  session.timestamp = context.timestamp || timestampInSeconds();\n\n  if (context.abnormal_mechanism) {\n    session.abnormal_mechanism = context.abnormal_mechanism;\n  }\n\n  if (context.ignoreDuration) {\n    session.ignoreDuration = context.ignoreDuration;\n  }\n  if (context.sid) {\n    // Good enough uuid validation. â€” Kamil\n    session.sid = context.sid.length === 32 ? context.sid : uuid4();\n  }\n  if (context.init !== undefined) {\n    session.init = context.init;\n  }\n  if (!session.did && context.did) {\n    session.did = `${context.did}`;\n  }\n  if (typeof context.started === 'number') {\n    session.started = context.started;\n  }\n  if (session.ignoreDuration) {\n    session.duration = undefined;\n  } else if (typeof context.duration === 'number') {\n    session.duration = context.duration;\n  } else {\n    const duration = session.timestamp - session.started;\n    session.duration = duration >= 0 ? duration : 0;\n  }\n  if (context.release) {\n    session.release = context.release;\n  }\n  if (context.environment) {\n    session.environment = context.environment;\n  }\n  if (!session.ipAddress && context.ipAddress) {\n    session.ipAddress = context.ipAddress;\n  }\n  if (!session.userAgent && context.userAgent) {\n    session.userAgent = context.userAgent;\n  }\n  if (typeof context.errors === 'number') {\n    session.errors = context.errors;\n  }\n  if (context.status) {\n    session.status = context.status;\n  }\n}\n\n/**\n * Closes a session by setting its status and updating the session object with it.\n * Internally calls `updateSession` to update the passed session object.\n *\n * Note that this function mutates the passed session (@see updateSession for explanation).\n *\n * @param session the `Session` object to be closed\n * @param status the `SessionStatus` with which the session was closed. If you don't pass a status,\n *               this function will keep the previously set status, unless it was `'ok'` in which case\n *               it is changed to `'exited'`.\n */\nfunction closeSession(session, status) {\n  let context = {};\n  if (status) {\n    context = { status };\n  } else if (session.status === 'ok') {\n    context = { status: 'exited' };\n  }\n\n  updateSession(session, context);\n}\n\n/**\n * Serializes a passed session object to a JSON object with a slightly different structure.\n * This is necessary because the Sentry backend requires a slightly different schema of a session\n * than the one the JS SDKs use internally.\n *\n * @param session the session to be converted\n *\n * @returns a JSON object of the passed session\n */\nfunction sessionToJSON(session) {\n  return {\n    sid: `${session.sid}`,\n    init: session.init,\n    // Make sure that sec is converted to ms for date constructor\n    started: new Date(session.started * 1000).toISOString(),\n    timestamp: new Date(session.timestamp * 1000).toISOString(),\n    status: session.status,\n    errors: session.errors,\n    did: typeof session.did === 'number' || typeof session.did === 'string' ? `${session.did}` : undefined,\n    duration: session.duration,\n    abnormal_mechanism: session.abnormal_mechanism,\n    attrs: {\n      release: session.release,\n      environment: session.environment,\n      ip_address: session.ipAddress,\n      user_agent: session.userAgent,\n    },\n  };\n}\n\nexport { closeSession, makeSession, updateSession };\n//# sourceMappingURL=session.js.map\n","/**\n * Shallow merge two objects.\n * Does not mutate the passed in objects.\n * Undefined/empty values in the merge object will overwrite existing values.\n *\n * By default, this merges 2 levels deep.\n */\nfunction merge(initialObj, mergeObj, levels = 2) {\n  // If the merge value is not an object, or we have no merge levels left,\n  // we just set the value to the merge value\n  if (!mergeObj || typeof mergeObj !== 'object' || levels <= 0) {\n    return mergeObj;\n  }\n\n  // If the merge object is an empty object, and the initial object is not undefined, we return the initial object\n  if (initialObj && Object.keys(mergeObj).length === 0) {\n    return initialObj;\n  }\n\n  // Clone object\n  const output = { ...initialObj };\n\n  // Merge values into output, resursively\n  for (const key in mergeObj) {\n    if (Object.prototype.hasOwnProperty.call(mergeObj, key)) {\n      output[key] = merge(output[key], mergeObj[key], levels - 1);\n    }\n  }\n\n  return output;\n}\n\nexport { merge };\n//# sourceMappingURL=merge.js.map\n","import { uuid4 } from './misc.js';\n\n/**\n * Generate a random, valid trace ID.\n */\nfunction generateTraceId() {\n  return uuid4();\n}\n\n/**\n * Generate a random, valid span ID.\n */\nfunction generateSpanId() {\n  return uuid4().substring(16);\n}\n\nexport { generateSpanId, generateTraceId };\n//# sourceMappingURL=propagationContext.js.map\n","import { addNonEnumerableProperty } from './object.js';\n\nconst SCOPE_SPAN_FIELD = '_sentrySpan';\n\n/**\n * Set the active span for a given scope.\n * NOTE: This should NOT be used directly, but is only used internally by the trace methods.\n */\nfunction _setSpanForScope(scope, span) {\n  if (span) {\n    addNonEnumerableProperty(scope , SCOPE_SPAN_FIELD, span);\n  } else {\n    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n    delete (scope )[SCOPE_SPAN_FIELD];\n  }\n}\n\n/**\n * Get the active span for a given scope.\n * NOTE: This should NOT be used directly, but is only used internally by the trace methods.\n */\nfunction _getSpanForScope(scope) {\n  return scope[SCOPE_SPAN_FIELD];\n}\n\nexport { _getSpanForScope, _setSpanForScope };\n//# sourceMappingURL=spanOnScope.js.map\n","import { DEBUG_BUILD } from './debug-build.js';\nimport { updateSession } from './session.js';\nimport { debug } from './utils/debug-logger.js';\nimport { isPlainObject } from './utils/is.js';\nimport { merge } from './utils/merge.js';\nimport { uuid4 } from './utils/misc.js';\nimport { generateTraceId } from './utils/propagationContext.js';\nimport { safeMathRandom } from './utils/randomSafeContext.js';\nimport { _setSpanForScope, _getSpanForScope } from './utils/spanOnScope.js';\nimport { truncate } from './utils/string.js';\nimport { dateTimestampInSeconds } from './utils/time.js';\n\n/**\n * Default value for maximum number of breadcrumbs added to an event.\n */\nconst DEFAULT_MAX_BREADCRUMBS = 100;\n\n/**\n * A context to be used for capturing an event.\n * This can either be a Scope, or a partial ScopeContext,\n * or a callback that receives the current scope and returns a new scope to use.\n */\n\n/**\n * Holds additional event information.\n */\nclass Scope {\n  /** Flag if notifying is happening. */\n\n  /** Callback for client to receive scope changes. */\n\n  /** Callback list that will be called during event processing. */\n\n  /** Array of breadcrumbs. */\n\n  /** User */\n\n  /** Tags */\n\n  /** Attributes */\n\n  /** Extra */\n\n  /** Contexts */\n\n  /** Attachments */\n\n  /** Propagation Context for distributed tracing */\n\n  /**\n   * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get\n   * sent to Sentry\n   */\n\n  /** Fingerprint */\n\n  /** Severity */\n\n  /**\n   * Transaction Name\n   *\n   * IMPORTANT: The transaction name on the scope has nothing to do with root spans/transaction objects.\n   * It's purpose is to assign a transaction to the scope that's added to non-transaction events.\n   */\n\n  /** Session */\n\n  /** The client on this scope */\n\n  /** Contains the last event id of a captured event.  */\n\n  /** Conversation ID */\n\n  // NOTE: Any field which gets added here should get added not only to the constructor but also to the `clone` method.\n\n   constructor() {\n    this._notifyingListeners = false;\n    this._scopeListeners = [];\n    this._eventProcessors = [];\n    this._breadcrumbs = [];\n    this._attachments = [];\n    this._user = {};\n    this._tags = {};\n    this._attributes = {};\n    this._extra = {};\n    this._contexts = {};\n    this._sdkProcessingMetadata = {};\n    this._propagationContext = {\n      traceId: generateTraceId(),\n      sampleRand: safeMathRandom(),\n    };\n  }\n\n  /**\n   * Clone all data from this scope into a new scope.\n   */\n   clone() {\n    const newScope = new Scope();\n    newScope._breadcrumbs = [...this._breadcrumbs];\n    newScope._tags = { ...this._tags };\n    newScope._attributes = { ...this._attributes };\n    newScope._extra = { ...this._extra };\n    newScope._contexts = { ...this._contexts };\n    if (this._contexts.flags) {\n      // We need to copy the `values` array so insertions on a cloned scope\n      // won't affect the original array.\n      newScope._contexts.flags = {\n        values: [...this._contexts.flags.values],\n      };\n    }\n\n    newScope._user = this._user;\n    newScope._level = this._level;\n    newScope._session = this._session;\n    newScope._transactionName = this._transactionName;\n    newScope._fingerprint = this._fingerprint;\n    newScope._eventProcessors = [...this._eventProcessors];\n    newScope._attachments = [...this._attachments];\n    newScope._sdkProcessingMetadata = { ...this._sdkProcessingMetadata };\n    newScope._propagationContext = { ...this._propagationContext };\n    newScope._client = this._client;\n    newScope._lastEventId = this._lastEventId;\n    newScope._conversationId = this._conversationId;\n\n    _setSpanForScope(newScope, _getSpanForScope(this));\n\n    return newScope;\n  }\n\n  /**\n   * Update the client assigned to this scope.\n   * Note that not every scope will have a client assigned - isolation scopes & the global scope will generally not have a client,\n   * as well as manually created scopes.\n   */\n   setClient(client) {\n    this._client = client;\n  }\n\n  /**\n   * Set the ID of the last captured error event.\n   * This is generally only captured on the isolation scope.\n   */\n   setLastEventId(lastEventId) {\n    this._lastEventId = lastEventId;\n  }\n\n  /**\n   * Get the client assigned to this scope.\n   */\n   getClient() {\n    return this._client ;\n  }\n\n  /**\n   * Get the ID of the last captured error event.\n   * This is generally only available on the isolation scope.\n   */\n   lastEventId() {\n    return this._lastEventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   addScopeListener(callback) {\n    this._scopeListeners.push(callback);\n  }\n\n  /**\n   * Add an event processor that will be called before an event is sent.\n   */\n   addEventProcessor(callback) {\n    this._eventProcessors.push(callback);\n    return this;\n  }\n\n  /**\n   * Set the user for this scope.\n   * Set to `null` to unset the user.\n   */\n   setUser(user) {\n    // If null is passed we want to unset everything, but still define keys,\n    // so that later down in the pipeline any existing values are cleared.\n    this._user = user || {\n      email: undefined,\n      id: undefined,\n      ip_address: undefined,\n      username: undefined,\n    };\n\n    if (this._session) {\n      updateSession(this._session, { user });\n    }\n\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Get the user from this scope.\n   */\n   getUser() {\n    return this._user;\n  }\n\n  /**\n   * Set the conversation ID for this scope.\n   * Set to `null` to unset the conversation ID.\n   */\n   setConversationId(conversationId) {\n    this._conversationId = conversationId || undefined;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Set an object that will be merged into existing tags on the scope,\n   * and will be sent as tags data with the event.\n   */\n   setTags(tags) {\n    this._tags = {\n      ...this._tags,\n      ...tags,\n    };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Set a single tag that will be sent as tags data with the event.\n   */\n   setTag(key, value) {\n    return this.setTags({ [key]: value });\n  }\n\n  /**\n   * Sets attributes onto the scope.\n   *\n   * These attributes are currently applied to logs and metrics.\n   * In the future, they will also be applied to spans.\n   *\n   * Important: For now, only strings, numbers and boolean attributes are supported, despite types allowing for\n   * more complex attribute types. We'll add this support in the future but already specify the wider type to\n   * avoid a breaking change in the future.\n   *\n   * @param newAttributes - The attributes to set on the scope. You can either pass in key-value pairs, or\n   * an object with a `value` and an optional `unit` (if applicable to your attribute).\n   *\n   * @example\n   * ```typescript\n   * scope.setAttributes({\n   *   is_admin: true,\n   *   payment_selection: 'credit_card',\n   *   render_duration: { value: 'render_duration', unit: 'ms' },\n   * });\n   * ```\n   */\n   setAttributes(newAttributes) {\n    this._attributes = {\n      ...this._attributes,\n      ...newAttributes,\n    };\n\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Sets an attribute onto the scope.\n   *\n   * These attributes are currently applied to logs and metrics.\n   * In the future, they will also be applied to spans.\n   *\n   * Important: For now, only strings, numbers and boolean attributes are supported, despite types allowing for\n   * more complex attribute types. We'll add this support in the future but already specify the wider type to\n   * avoid a breaking change in the future.\n   *\n   * @param key - The attribute key.\n   * @param value - the attribute value. You can either pass in a raw value, or an attribute\n   * object with a `value` and an optional `unit` (if applicable to your attribute).\n   *\n   * @example\n   * ```typescript\n   * scope.setAttribute('is_admin', true);\n   * scope.setAttribute('render_duration', { value: 'render_duration', unit: 'ms' });\n   * ```\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n   setAttribute(\n    key,\n    value,\n  ) {\n    return this.setAttributes({ [key]: value });\n  }\n\n  /**\n   * Removes the attribute with the given key from the scope.\n   *\n   * @param key - The attribute key.\n   *\n   * @example\n   * ```typescript\n   * scope.removeAttribute('is_admin');\n   * ```\n   */\n   removeAttribute(key) {\n    if (key in this._attributes) {\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this._attributes[key];\n      this._notifyScopeListeners();\n    }\n    return this;\n  }\n\n  /**\n   * Set an object that will be merged into existing extra on the scope,\n   * and will be sent as extra data with the event.\n   */\n   setExtras(extras) {\n    this._extra = {\n      ...this._extra,\n      ...extras,\n    };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Set a single key:value extra entry that will be sent as extra data with the event.\n   */\n   setExtra(key, extra) {\n    this._extra = { ...this._extra, [key]: extra };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Sets the fingerprint on the scope to send with the events.\n   * @param {string[]} fingerprint Fingerprint to group events in Sentry.\n   */\n   setFingerprint(fingerprint) {\n    this._fingerprint = fingerprint;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Sets the level on the scope for future events.\n   */\n   setLevel(level) {\n    this._level = level;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Sets the transaction name on the scope so that the name of e.g. taken server route or\n   * the page location is attached to future events.\n   *\n   * IMPORTANT: Calling this function does NOT change the name of the currently active\n   * root span. If you want to change the name of the active root span, use\n   * `Sentry.updateSpanName(rootSpan, 'new name')` instead.\n   *\n   * By default, the SDK updates the scope's transaction name automatically on sensible\n   * occasions, such as a page navigation or when handling a new request on the server.\n   */\n   setTransactionName(name) {\n    this._transactionName = name;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Sets context data with the given name.\n   * Data passed as context will be normalized. You can also pass `null` to unset the context.\n   * Note that context data will not be merged - calling `setContext` will overwrite an existing context with the same key.\n   */\n   setContext(key, context) {\n    if (context === null) {\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this._contexts[key];\n    } else {\n      this._contexts[key] = context;\n    }\n\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Set the session for the scope.\n   */\n   setSession(session) {\n    if (!session) {\n      delete this._session;\n    } else {\n      this._session = session;\n    }\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Get the session from the scope.\n   */\n   getSession() {\n    return this._session;\n  }\n\n  /**\n   * Updates the scope with provided data. Can work in three variations:\n   * - plain object containing updatable attributes\n   * - Scope instance that'll extract the attributes from\n   * - callback function that'll receive the current scope as an argument and allow for modifications\n   */\n   update(captureContext) {\n    if (!captureContext) {\n      return this;\n    }\n\n    const scopeToMerge = typeof captureContext === 'function' ? captureContext(this) : captureContext;\n\n    const scopeInstance =\n      scopeToMerge instanceof Scope\n        ? scopeToMerge.getScopeData()\n        : isPlainObject(scopeToMerge)\n          ? (captureContext )\n          : undefined;\n\n    const {\n      tags,\n      attributes,\n      extra,\n      user,\n      contexts,\n      level,\n      fingerprint = [],\n      propagationContext,\n      conversationId,\n    } = scopeInstance || {};\n\n    this._tags = { ...this._tags, ...tags };\n    this._attributes = { ...this._attributes, ...attributes };\n    this._extra = { ...this._extra, ...extra };\n    this._contexts = { ...this._contexts, ...contexts };\n\n    if (user && Object.keys(user).length) {\n      this._user = user;\n    }\n\n    if (level) {\n      this._level = level;\n    }\n\n    if (fingerprint.length) {\n      this._fingerprint = fingerprint;\n    }\n\n    if (propagationContext) {\n      this._propagationContext = propagationContext;\n    }\n\n    if (conversationId) {\n      this._conversationId = conversationId;\n    }\n\n    return this;\n  }\n\n  /**\n   * Clears the current scope and resets its properties.\n   * Note: The client will not be cleared.\n   */\n   clear() {\n    // client is not cleared here on purpose!\n    this._breadcrumbs = [];\n    this._tags = {};\n    this._attributes = {};\n    this._extra = {};\n    this._user = {};\n    this._contexts = {};\n    this._level = undefined;\n    this._transactionName = undefined;\n    this._fingerprint = undefined;\n    this._session = undefined;\n    this._conversationId = undefined;\n    _setSpanForScope(this, undefined);\n    this._attachments = [];\n    this.setPropagationContext({\n      traceId: generateTraceId(),\n      sampleRand: safeMathRandom(),\n    });\n\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Adds a breadcrumb to the scope.\n   * By default, the last 100 breadcrumbs are kept.\n   */\n   addBreadcrumb(breadcrumb, maxBreadcrumbs) {\n    const maxCrumbs = typeof maxBreadcrumbs === 'number' ? maxBreadcrumbs : DEFAULT_MAX_BREADCRUMBS;\n\n    // No data has been changed, so don't notify scope listeners\n    if (maxCrumbs <= 0) {\n      return this;\n    }\n\n    const mergedBreadcrumb = {\n      timestamp: dateTimestampInSeconds(),\n      ...breadcrumb,\n      // Breadcrumb messages can theoretically be infinitely large and they're held in memory so we truncate them not to leak (too much) memory\n      message: breadcrumb.message ? truncate(breadcrumb.message, 2048) : breadcrumb.message,\n    };\n\n    this._breadcrumbs.push(mergedBreadcrumb);\n    if (this._breadcrumbs.length > maxCrumbs) {\n      this._breadcrumbs = this._breadcrumbs.slice(-maxCrumbs);\n      this._client?.recordDroppedEvent('buffer_overflow', 'log_item');\n    }\n\n    this._notifyScopeListeners();\n\n    return this;\n  }\n\n  /**\n   * Get the last breadcrumb of the scope.\n   */\n   getLastBreadcrumb() {\n    return this._breadcrumbs[this._breadcrumbs.length - 1];\n  }\n\n  /**\n   * Clear all breadcrumbs from the scope.\n   */\n   clearBreadcrumbs() {\n    this._breadcrumbs = [];\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Add an attachment to the scope.\n   */\n   addAttachment(attachment) {\n    this._attachments.push(attachment);\n    return this;\n  }\n\n  /**\n   * Clear all attachments from the scope.\n   */\n   clearAttachments() {\n    this._attachments = [];\n    return this;\n  }\n\n  /**\n   * Get the data of this scope, which should be applied to an event during processing.\n   */\n   getScopeData() {\n    return {\n      breadcrumbs: this._breadcrumbs,\n      attachments: this._attachments,\n      contexts: this._contexts,\n      tags: this._tags,\n      attributes: this._attributes,\n      extra: this._extra,\n      user: this._user,\n      level: this._level,\n      fingerprint: this._fingerprint || [],\n      eventProcessors: this._eventProcessors,\n      propagationContext: this._propagationContext,\n      sdkProcessingMetadata: this._sdkProcessingMetadata,\n      transactionName: this._transactionName,\n      span: _getSpanForScope(this),\n      conversationId: this._conversationId,\n    };\n  }\n\n  /**\n   * Add data which will be accessible during event processing but won't get sent to Sentry.\n   */\n   setSDKProcessingMetadata(newData) {\n    this._sdkProcessingMetadata = merge(this._sdkProcessingMetadata, newData, 2);\n    return this;\n  }\n\n  /**\n   * Add propagation context to the scope, used for distributed tracing\n   */\n   setPropagationContext(context) {\n    this._propagationContext = context;\n    return this;\n  }\n\n  /**\n   * Get propagation context from the scope, used for distributed tracing\n   */\n   getPropagationContext() {\n    return this._propagationContext;\n  }\n\n  /**\n   * Capture an exception for this scope.\n   *\n   * @returns {string} The id of the captured Sentry event.\n   */\n   captureException(exception, hint) {\n    const eventId = hint?.event_id || uuid4();\n\n    if (!this._client) {\n      DEBUG_BUILD && debug.warn('No client configured on scope - will not capture exception!');\n      return eventId;\n    }\n\n    const syntheticException = new Error('Sentry syntheticException');\n\n    this._client.captureException(\n      exception,\n      {\n        originalException: exception,\n        syntheticException,\n        ...hint,\n        event_id: eventId,\n      },\n      this,\n    );\n\n    return eventId;\n  }\n\n  /**\n   * Capture a message for this scope.\n   *\n   * @returns {string} The id of the captured message.\n   */\n   captureMessage(message, level, hint) {\n    const eventId = hint?.event_id || uuid4();\n\n    if (!this._client) {\n      DEBUG_BUILD && debug.warn('No client configured on scope - will not capture message!');\n      return eventId;\n    }\n\n    const syntheticException = hint?.syntheticException ?? new Error(message);\n\n    this._client.captureMessage(\n      message,\n      level,\n      {\n        originalException: message,\n        syntheticException,\n        ...hint,\n        event_id: eventId,\n      },\n      this,\n    );\n\n    return eventId;\n  }\n\n  /**\n   * Capture a Sentry event for this scope.\n   *\n   * @returns {string} The id of the captured event.\n   */\n   captureEvent(event, hint) {\n    const eventId = event.event_id || hint?.event_id || uuid4();\n\n    if (!this._client) {\n      DEBUG_BUILD && debug.warn('No client configured on scope - will not capture event!');\n      return eventId;\n    }\n\n    this._client.captureEvent(event, { ...hint, event_id: eventId }, this);\n\n    return eventId;\n  }\n\n  /**\n   * This will be called on every set call.\n   */\n   _notifyScopeListeners() {\n    // We need this check for this._notifyingListeners to be able to work on scope during updates\n    // If this check is not here we'll produce endless recursion when something is done with the scope\n    // during the callback.\n    if (!this._notifyingListeners) {\n      this._notifyingListeners = true;\n      this._scopeListeners.forEach(callback => {\n        callback(this);\n      });\n      this._notifyingListeners = false;\n    }\n  }\n}\n\nexport { Scope };\n//# sourceMappingURL=scope.js.map\n","import { getGlobalSingleton } from './carrier.js';\nimport { Scope } from './scope.js';\n\n/** Get the default current scope. */\nfunction getDefaultCurrentScope() {\n  return getGlobalSingleton('defaultCurrentScope', () => new Scope());\n}\n\n/** Get the default isolation scope. */\nfunction getDefaultIsolationScope() {\n  return getGlobalSingleton('defaultIsolationScope', () => new Scope());\n}\n\nexport { getDefaultCurrentScope, getDefaultIsolationScope };\n//# sourceMappingURL=defaultScopes.js.map\n","import { getDefaultCurrentScope, getDefaultIsolationScope } from '../defaultScopes.js';\nimport { Scope } from '../scope.js';\nimport { isThenable } from '../utils/is.js';\nimport { getMainCarrier, getSentryCarrier } from '../carrier.js';\n\n/**\n * This is an object that holds a stack of scopes.\n */\nclass AsyncContextStack {\n\n   constructor(scope, isolationScope) {\n    let assignedScope;\n    if (!scope) {\n      assignedScope = new Scope();\n    } else {\n      assignedScope = scope;\n    }\n\n    let assignedIsolationScope;\n    if (!isolationScope) {\n      assignedIsolationScope = new Scope();\n    } else {\n      assignedIsolationScope = isolationScope;\n    }\n\n    // scope stack for domains or the process\n    this._stack = [{ scope: assignedScope }];\n    this._isolationScope = assignedIsolationScope;\n  }\n\n  /**\n   * Fork a scope for the stack.\n   */\n   withScope(callback) {\n    const scope = this._pushScope();\n\n    let maybePromiseResult;\n    try {\n      maybePromiseResult = callback(scope);\n    } catch (e) {\n      this._popScope();\n      throw e;\n    }\n\n    if (isThenable(maybePromiseResult)) {\n      // @ts-expect-error - isThenable returns the wrong type\n      return maybePromiseResult.then(\n        res => {\n          this._popScope();\n          return res;\n        },\n        e => {\n          this._popScope();\n          throw e;\n        },\n      );\n    }\n\n    this._popScope();\n    return maybePromiseResult;\n  }\n\n  /**\n   * Get the client of the stack.\n   */\n   getClient() {\n    return this.getStackTop().client ;\n  }\n\n  /**\n   * Returns the scope of the top stack.\n   */\n   getScope() {\n    return this.getStackTop().scope;\n  }\n\n  /**\n   * Get the isolation scope for the stack.\n   */\n   getIsolationScope() {\n    return this._isolationScope;\n  }\n\n  /**\n   * Returns the topmost scope layer in the order domain > local > process.\n   */\n   getStackTop() {\n    return this._stack[this._stack.length - 1] ;\n  }\n\n  /**\n   * Push a scope to the stack.\n   */\n   _pushScope() {\n    // We want to clone the content of prev scope\n    const scope = this.getScope().clone();\n    this._stack.push({\n      client: this.getClient(),\n      scope,\n    });\n    return scope;\n  }\n\n  /**\n   * Pop a scope from the stack.\n   */\n   _popScope() {\n    if (this._stack.length <= 1) return false;\n    return !!this._stack.pop();\n  }\n}\n\n/**\n * Get the global async context stack.\n * This will be removed during the v8 cycle and is only here to make migration easier.\n */\nfunction getAsyncContextStack() {\n  const registry = getMainCarrier();\n  const sentry = getSentryCarrier(registry);\n\n  return (sentry.stack = sentry.stack || new AsyncContextStack(getDefaultCurrentScope(), getDefaultIsolationScope()));\n}\n\nfunction withScope(callback) {\n  return getAsyncContextStack().withScope(callback);\n}\n\nfunction withSetScope(scope, callback) {\n  const stack = getAsyncContextStack();\n  return stack.withScope(() => {\n    stack.getStackTop().scope = scope;\n    return callback(scope);\n  });\n}\n\nfunction withIsolationScope(callback) {\n  return getAsyncContextStack().withScope(() => {\n    return callback(getAsyncContextStack().getIsolationScope());\n  });\n}\n\n/**\n * Get the stack-based async context strategy.\n */\nfunction getStackAsyncContextStrategy() {\n  return {\n    withIsolationScope,\n    withScope,\n    withSetScope,\n    withSetIsolationScope: (_isolationScope, callback) => {\n      return withIsolationScope(callback);\n    },\n    getCurrentScope: () => getAsyncContextStack().getScope(),\n    getIsolationScope: () => getAsyncContextStack().getIsolationScope(),\n  };\n}\n\nexport { AsyncContextStack, getStackAsyncContextStrategy };\n//# sourceMappingURL=stackStrategy.js.map\n","import { getMainCarrier, getSentryCarrier } from '../carrier.js';\nimport { getStackAsyncContextStrategy } from './stackStrategy.js';\n\n/**\n * @private Private API with no semver guarantees!\n *\n * Sets the global async context strategy\n */\nfunction setAsyncContextStrategy(strategy) {\n  // Get main carrier (global for every environment)\n  const registry = getMainCarrier();\n  const sentry = getSentryCarrier(registry);\n  sentry.acs = strategy;\n}\n\n/**\n * Get the current async context strategy.\n * If none has been setup, the default will be used.\n */\nfunction getAsyncContextStrategy(carrier) {\n  const sentry = getSentryCarrier(carrier);\n\n  if (sentry.acs) {\n    return sentry.acs;\n  }\n\n  // Otherwise, use the default one (stack)\n  return getStackAsyncContextStrategy();\n}\n\nexport { getAsyncContextStrategy, setAsyncContextStrategy };\n//# sourceMappingURL=index.js.map\n","import { getAsyncContextStrategy } from './asyncContext/index.js';\nimport { getMainCarrier, getGlobalSingleton } from './carrier.js';\nimport { Scope } from './scope.js';\nimport { generateSpanId } from './utils/propagationContext.js';\n\n/**\n * Get the currently active scope.\n */\nfunction getCurrentScope() {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n  return acs.getCurrentScope();\n}\n\n/**\n * Get the currently active isolation scope.\n * The isolation scope is active for the current execution context.\n */\nfunction getIsolationScope() {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n  return acs.getIsolationScope();\n}\n\n/**\n * Get the global scope.\n * This scope is applied to _all_ events.\n */\nfunction getGlobalScope() {\n  return getGlobalSingleton('globalScope', () => new Scope());\n}\n\n/**\n * Creates a new scope with and executes the given operation within.\n * The scope is automatically removed once the operation\n * finishes or throws.\n */\n\n/**\n * Either creates a new active scope, or sets the given scope as active scope in the given callback.\n */\nfunction withScope(\n  ...rest\n) {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n\n  // If a scope is defined, we want to make this the active scope instead of the default one\n  if (rest.length === 2) {\n    const [scope, callback] = rest;\n\n    if (!scope) {\n      return acs.withScope(callback);\n    }\n\n    return acs.withSetScope(scope, callback);\n  }\n\n  return acs.withScope(rest[0]);\n}\n\n/**\n * Attempts to fork the current isolation scope and the current scope based on the current async context strategy. If no\n * async context strategy is set, the isolation scope and the current scope will not be forked (this is currently the\n * case, for example, in the browser).\n *\n * Usage of this function in environments without async context strategy is discouraged and may lead to unexpected behaviour.\n *\n * This function is intended for Sentry SDK and SDK integration development. It is not recommended to be used in \"normal\"\n * applications directly because it comes with pitfalls. Use at your own risk!\n */\n\n/**\n * Either creates a new active isolation scope, or sets the given isolation scope as active scope in the given callback.\n */\nfunction withIsolationScope(\n  ...rest\n\n) {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n\n  // If a scope is defined, we want to make this the active scope instead of the default one\n  if (rest.length === 2) {\n    const [isolationScope, callback] = rest;\n\n    if (!isolationScope) {\n      return acs.withIsolationScope(callback);\n    }\n\n    return acs.withSetIsolationScope(isolationScope, callback);\n  }\n\n  return acs.withIsolationScope(rest[0]);\n}\n\n/**\n * Get the currently active client.\n */\nfunction getClient() {\n  return getCurrentScope().getClient();\n}\n\n/**\n * Get a trace context for the given scope.\n */\nfunction getTraceContextFromScope(scope) {\n  const propagationContext = scope.getPropagationContext();\n\n  const { traceId, parentSpanId, propagationSpanId } = propagationContext;\n\n  const traceContext = {\n    trace_id: traceId,\n    span_id: propagationSpanId || generateSpanId(),\n  };\n\n  if (parentSpanId) {\n    traceContext.parent_span_id = parentSpanId;\n  }\n\n  return traceContext;\n}\n\nexport { getClient, getCurrentScope, getGlobalScope, getIsolationScope, getTraceContextFromScope, withIsolationScope, withScope };\n//# sourceMappingURL=currentScopes.js.map\n","import { DEFAULT_ENVIRONMENT } from '../constants.js';\nimport { notifyEventProcessors } from '../eventProcessors.js';\nimport { Scope } from '../scope.js';\nimport { getFilenameToDebugIdMap } from './debug-ids.js';\nimport { uuid4, addExceptionMechanism } from './misc.js';\nimport { normalize } from './normalize.js';\nimport { getCombinedScopeData, applyScopeDataToEvent } from './scopeData.js';\nimport { truncate } from './string.js';\nimport { resolvedSyncPromise } from './syncpromise.js';\nimport { dateTimestampInSeconds } from './time.js';\n\n/**\n * This type makes sure that we get either a CaptureContext, OR an EventHint.\n * It does not allow mixing them, which could lead to unexpected outcomes, e.g. this is disallowed:\n * { user: { id: '123' }, mechanism: { handled: false } }\n */\n\n/**\n * Adds common information to events.\n *\n * The information includes release and environment from `options`,\n * breadcrumbs and context (extra, tags and user) from the scope.\n *\n * Information that is already present in the event is never overwritten. For\n * nested objects, such as the context, keys are merged.\n *\n * @param event The original event.\n * @param hint May contain additional information about the original exception.\n * @param scope A scope containing event metadata.\n * @returns A new event with more information.\n * @hidden\n */\nfunction prepareEvent(\n  options,\n  event,\n  hint,\n  scope,\n  client,\n  isolationScope,\n) {\n  const { normalizeDepth = 3, normalizeMaxBreadth = 1000 } = options;\n  const prepared = {\n    ...event,\n    event_id: event.event_id || hint.event_id || uuid4(),\n    timestamp: event.timestamp || dateTimestampInSeconds(),\n  };\n  const integrations = hint.integrations || options.integrations.map(i => i.name);\n\n  applyClientOptions(prepared, options);\n  applyIntegrationsMetadata(prepared, integrations);\n\n  if (client) {\n    client.emit('applyFrameMetadata', event);\n  }\n\n  // Only put debug IDs onto frames for error events.\n  if (event.type === undefined) {\n    applyDebugIds(prepared, options.stackParser);\n  }\n\n  // If we have scope given to us, use it as the base for further modifications.\n  // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.\n  const finalScope = getFinalScope(scope, hint.captureContext);\n\n  if (hint.mechanism) {\n    addExceptionMechanism(prepared, hint.mechanism);\n  }\n\n  const clientEventProcessors = client ? client.getEventProcessors() : [];\n\n  // This should be the last thing called, since we want that\n  // {@link Scope.addEventProcessor} gets the finished prepared event.\n  // Merge scope data together\n  const data = getCombinedScopeData(isolationScope, finalScope);\n\n  const attachments = [...(hint.attachments || []), ...data.attachments];\n  if (attachments.length) {\n    hint.attachments = attachments;\n  }\n\n  applyScopeDataToEvent(prepared, data);\n\n  const eventProcessors = [\n    ...clientEventProcessors,\n    // Run scope event processors _after_ all other processors\n    ...data.eventProcessors,\n  ];\n\n  // Skip event processors for internal exceptions to prevent recursion\n  const isInternalException = hint.data && (hint.data ).__sentry__ === true;\n  const result = isInternalException\n    ? resolvedSyncPromise(prepared)\n    : notifyEventProcessors(eventProcessors, prepared, hint);\n\n  return result.then(evt => {\n    if (evt) {\n      // We apply the debug_meta field only after all event processors have ran, so that if any event processors modified\n      // file names (e.g.the RewriteFrames integration) the filename -> debug ID relationship isn't destroyed.\n      // This should not cause any PII issues, since we're only moving data that is already on the event and not adding\n      // any new data\n      applyDebugMeta(evt);\n    }\n\n    if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {\n      return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);\n    }\n    return evt;\n  });\n}\n\n/**\n * Enhances event using the client configuration.\n * It takes care of all \"static\" values like environment, release and `dist`,\n * as well as truncating overly long values.\n *\n * Only exported for tests.\n *\n * @param event event instance to be enhanced\n */\nfunction applyClientOptions(event, options) {\n  const { environment, release, dist, maxValueLength } = options;\n\n  // empty strings do not make sense for environment, release, and dist\n  // so we handle them the same as if they were not provided\n  event.environment = event.environment || environment || DEFAULT_ENVIRONMENT;\n\n  if (!event.release && release) {\n    event.release = release;\n  }\n\n  if (!event.dist && dist) {\n    event.dist = dist;\n  }\n\n  const request = event.request;\n  if (request?.url && maxValueLength) {\n    request.url = truncate(request.url, maxValueLength);\n  }\n\n  if (maxValueLength) {\n    event.exception?.values?.forEach(exception => {\n      if (exception.value) {\n        // Truncates error messages\n        exception.value = truncate(exception.value, maxValueLength);\n      }\n    });\n  }\n}\n\n/**\n * Puts debug IDs into the stack frames of an error event.\n */\nfunction applyDebugIds(event, stackParser) {\n  // Build a map of filename -> debug_id\n  const filenameDebugIdMap = getFilenameToDebugIdMap(stackParser);\n\n  event.exception?.values?.forEach(exception => {\n    exception.stacktrace?.frames?.forEach(frame => {\n      if (frame.filename) {\n        frame.debug_id = filenameDebugIdMap[frame.filename];\n      }\n    });\n  });\n}\n\n/**\n * Moves debug IDs from the stack frames of an error event into the debug_meta field.\n */\nfunction applyDebugMeta(event) {\n  // Extract debug IDs and filenames from the stack frames on the event.\n  const filenameDebugIdMap = {};\n  event.exception?.values?.forEach(exception => {\n    exception.stacktrace?.frames?.forEach(frame => {\n      if (frame.debug_id) {\n        if (frame.abs_path) {\n          filenameDebugIdMap[frame.abs_path] = frame.debug_id;\n        } else if (frame.filename) {\n          filenameDebugIdMap[frame.filename] = frame.debug_id;\n        }\n        delete frame.debug_id;\n      }\n    });\n  });\n\n  if (Object.keys(filenameDebugIdMap).length === 0) {\n    return;\n  }\n\n  // Fill debug_meta information\n  event.debug_meta = event.debug_meta || {};\n  event.debug_meta.images = event.debug_meta.images || [];\n  const images = event.debug_meta.images;\n  Object.entries(filenameDebugIdMap).forEach(([filename, debug_id]) => {\n    images.push({\n      type: 'sourcemap',\n      code_file: filename,\n      debug_id,\n    });\n  });\n}\n\n/**\n * This function adds all used integrations to the SDK info in the event.\n * @param event The event that will be filled with all integrations.\n */\nfunction applyIntegrationsMetadata(event, integrationNames) {\n  if (integrationNames.length > 0) {\n    event.sdk = event.sdk || {};\n    event.sdk.integrations = [...(event.sdk.integrations || []), ...integrationNames];\n  }\n}\n\n/**\n * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.\n * Normalized keys:\n * - `breadcrumbs.data`\n * - `user`\n * - `contexts`\n * - `extra`\n * @param event Event\n * @returns Normalized event\n */\nfunction normalizeEvent(event, depth, maxBreadth) {\n  if (!event) {\n    return null;\n  }\n\n  const normalized = {\n    ...event,\n    ...(event.breadcrumbs && {\n      breadcrumbs: event.breadcrumbs.map(b => ({\n        ...b,\n        ...(b.data && {\n          data: normalize(b.data, depth, maxBreadth),\n        }),\n      })),\n    }),\n    ...(event.user && {\n      user: normalize(event.user, depth, maxBreadth),\n    }),\n    ...(event.contexts && {\n      contexts: normalize(event.contexts, depth, maxBreadth),\n    }),\n    ...(event.extra && {\n      extra: normalize(event.extra, depth, maxBreadth),\n    }),\n  };\n\n  // event.contexts.trace stores information about a Transaction. Similarly,\n  // event.spans[] stores information about child Spans. Given that a\n  // Transaction is conceptually a Span, normalization should apply to both\n  // Transactions and Spans consistently.\n  // For now the decision is to skip normalization of Transactions and Spans,\n  // so this block overwrites the normalized event to add back the original\n  // Transaction information prior to normalization.\n  if (event.contexts?.trace && normalized.contexts) {\n    normalized.contexts.trace = event.contexts.trace;\n\n    // event.contexts.trace.data may contain circular/dangerous data so we need to normalize it\n    if (event.contexts.trace.data) {\n      normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth);\n    }\n  }\n\n  // event.spans[].data may contain circular/dangerous data so we need to normalize it\n  if (event.spans) {\n    normalized.spans = event.spans.map(span => {\n      return {\n        ...span,\n        ...(span.data && {\n          data: normalize(span.data, depth, maxBreadth),\n        }),\n      };\n    });\n  }\n\n  // event.contexts.flags (FeatureFlagContext) stores context for our feature\n  // flag integrations. It has a greater nesting depth than our other typed\n  // Contexts, so we re-normalize with a fixed depth of 3 here. We do not want\n  // to skip this in case of conflicting, user-provided context.\n  if (event.contexts?.flags && normalized.contexts) {\n    normalized.contexts.flags = normalize(event.contexts.flags, 3, maxBreadth);\n  }\n\n  return normalized;\n}\n\nfunction getFinalScope(scope, captureContext) {\n  if (!captureContext) {\n    return scope;\n  }\n\n  const finalScope = scope ? scope.clone() : new Scope();\n  finalScope.update(captureContext);\n  return finalScope;\n}\n\n/**\n * Parse either an `EventHint` directly, or convert a `CaptureContext` to an `EventHint`.\n * This is used to allow to update method signatures that used to accept a `CaptureContext` but should now accept an `EventHint`.\n */\nfunction parseEventHintOrCaptureContext(\n  hint,\n) {\n  if (!hint) {\n    return undefined;\n  }\n\n  // If you pass a Scope or `() => Scope` as CaptureContext, we just return this as captureContext\n  if (hintIsScopeOrFunction(hint)) {\n    return { captureContext: hint };\n  }\n\n  if (hintIsScopeContext(hint)) {\n    return {\n      captureContext: hint,\n    };\n  }\n\n  return hint;\n}\n\nfunction hintIsScopeOrFunction(hint) {\n  return hint instanceof Scope || typeof hint === 'function';\n}\n\nconst captureContextKeys = [\n  'user',\n  'level',\n  'extra',\n  'contexts',\n  'tags',\n  'fingerprint',\n  'propagationContext',\n] ;\n\nfunction hintIsScopeContext(hint) {\n  return Object.keys(hint).some(key => captureContextKeys.includes(key ));\n}\n\nexport { applyClientOptions, applyDebugIds, applyDebugMeta, parseEventHintOrCaptureContext, prepareEvent };\n//# sourceMappingURL=prepareEvent.js.map\n","import { getIsolationScope, getCurrentScope, getClient, withIsolationScope } from './currentScopes.js';\nimport { DEBUG_BUILD } from './debug-build.js';\nimport { closeSession, makeSession, updateSession } from './session.js';\nimport { startNewTrace } from './tracing/trace.js';\nimport { debug } from './utils/debug-logger.js';\nimport { isThenable } from './utils/is.js';\nimport { uuid4 } from './utils/misc.js';\nimport { parseEventHintOrCaptureContext } from './utils/prepareEvent.js';\nimport { getCombinedScopeData } from './utils/scopeData.js';\nimport { timestampInSeconds } from './utils/time.js';\nimport { GLOBAL_OBJ } from './utils/worldwide.js';\n\n/**\n * Captures an exception event and sends it to Sentry.\n *\n * @param exception The exception to capture.\n * @param hint Optional additional data to attach to the Sentry event.\n * @returns the id of the captured Sentry event.\n */\nfunction captureException(exception, hint) {\n  return getCurrentScope().captureException(exception, parseEventHintOrCaptureContext(hint));\n}\n\n/**\n * Captures a message event and sends it to Sentry.\n *\n * @param message The message to send to Sentry.\n * @param captureContext Define the level of the message or pass in additional data to attach to the message.\n * @returns the id of the captured message.\n */\nfunction captureMessage(message, captureContext) {\n  // This is necessary to provide explicit scopes upgrade, without changing the original\n  // arity of the `captureMessage(message, level)` method.\n  const level = typeof captureContext === 'string' ? captureContext : undefined;\n  const hint = typeof captureContext !== 'string' ? { captureContext } : undefined;\n  return getCurrentScope().captureMessage(message, level, hint);\n}\n\n/**\n * Captures a manually created event and sends it to Sentry.\n *\n * @param event The event to send to Sentry.\n * @param hint Optional additional data to attach to the Sentry event.\n * @returns the id of the captured event.\n */\nfunction captureEvent(event, hint) {\n  return getCurrentScope().captureEvent(event, hint);\n}\n\n/**\n * Sets context data with the given name.\n * @param name of the context\n * @param context Any kind of data. This data will be normalized.\n */\nfunction setContext(name, context) {\n  getIsolationScope().setContext(name, context);\n}\n\n/**\n * Set an object that will be merged sent as extra data with the event.\n * @param extras Extras object to merge into current context.\n */\nfunction setExtras(extras) {\n  getIsolationScope().setExtras(extras);\n}\n\n/**\n * Set key:value that will be sent as extra data with the event.\n * @param key String of extra\n * @param extra Any kind of data. This data will be normalized.\n */\nfunction setExtra(key, extra) {\n  getIsolationScope().setExtra(key, extra);\n}\n\n/**\n * Set an object that will be merged sent as tags data with the event.\n * @param tags Tags context object to merge into current context.\n */\nfunction setTags(tags) {\n  getIsolationScope().setTags(tags);\n}\n\n/**\n * Set key:value that will be sent as tags data with the event.\n *\n * Can also be used to unset a tag, by passing `undefined`.\n *\n * @param key String key of tag\n * @param value Value of tag\n */\nfunction setTag(key, value) {\n  getIsolationScope().setTag(key, value);\n}\n\n/**\n * Updates user context information for future events.\n *\n * @param user User context object to be set in the current context. Pass `null` to unset the user.\n */\nfunction setUser(user) {\n  getIsolationScope().setUser(user);\n}\n\n/**\n * Sets the conversation ID for the current isolation scope.\n *\n * @param conversationId The conversation ID to set. Pass `null` or `undefined` to unset the conversation ID.\n */\nfunction setConversationId(conversationId) {\n  getIsolationScope().setConversationId(conversationId);\n}\n\n/**\n * The last error event id of the isolation scope.\n *\n * Warning: This function really returns the last recorded error event id on the current\n * isolation scope. If you call this function after handling a certain error and another error\n * is captured in between, the last one is returned instead of the one you might expect.\n * Also, ids of events that were never sent to Sentry (for example because\n * they were dropped in `beforeSend`) could be returned.\n *\n * @returns The last event id of the isolation scope.\n */\nfunction lastEventId() {\n  return getIsolationScope().lastEventId();\n}\n\n/**\n * Create a cron monitor check in and send it to Sentry.\n *\n * @param checkIn An object that describes a check in.\n * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n * to create a monitor automatically when sending a check in.\n */\nfunction captureCheckIn(checkIn, upsertMonitorConfig) {\n  const scope = getCurrentScope();\n  const client = getClient();\n  if (!client) {\n    DEBUG_BUILD && debug.warn('Cannot capture check-in. No client defined.');\n  } else if (!client.captureCheckIn) {\n    DEBUG_BUILD && debug.warn('Cannot capture check-in. Client does not support sending check-ins.');\n  } else {\n    return client.captureCheckIn(checkIn, upsertMonitorConfig, scope);\n  }\n\n  return uuid4();\n}\n\n/**\n * Wraps a callback with a cron monitor check in. The check in will be sent to Sentry when the callback finishes.\n *\n * @param monitorSlug The distinct slug of the monitor.\n * @param callback Callback to be monitored\n * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n * to create a monitor automatically when sending a check in.\n */\nfunction withMonitor(\n  monitorSlug,\n  callback,\n  upsertMonitorConfig,\n) {\n  function runCallback() {\n    const checkInId = captureCheckIn({ monitorSlug, status: 'in_progress' }, upsertMonitorConfig);\n    const now = timestampInSeconds();\n\n    function finishCheckIn(status) {\n      captureCheckIn({ monitorSlug, status, checkInId, duration: timestampInSeconds() - now });\n    }\n    // Default behavior without isolateTrace\n    let maybePromiseResult;\n    try {\n      maybePromiseResult = callback();\n    } catch (e) {\n      finishCheckIn('error');\n      throw e;\n    }\n\n    if (isThenable(maybePromiseResult)) {\n      return maybePromiseResult.then(\n        r => {\n          finishCheckIn('ok');\n          return r;\n        },\n        e => {\n          finishCheckIn('error');\n          throw e;\n        },\n      ) ;\n    }\n    finishCheckIn('ok');\n\n    return maybePromiseResult;\n  }\n\n  return withIsolationScope(() => (upsertMonitorConfig?.isolateTrace ? startNewTrace(runCallback) : runCallback()));\n}\n\n/**\n * Call `flush()` on the current client, if there is one. See {@link Client.flush}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue. Omitting this parameter will cause\n * the client to wait until all events are sent before resolving the promise.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nasync function flush(timeout) {\n  const client = getClient();\n  if (client) {\n    return client.flush(timeout);\n  }\n  DEBUG_BUILD && debug.warn('Cannot flush events. No client defined.');\n  return Promise.resolve(false);\n}\n\n/**\n * Call `close()` on the current client, if there is one. See {@link Client.close}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue before shutting down. Omitting this\n * parameter will cause the client to wait until all events are sent before disabling itself.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nasync function close(timeout) {\n  const client = getClient();\n  if (client) {\n    return client.close(timeout);\n  }\n  DEBUG_BUILD && debug.warn('Cannot flush events and disable SDK. No client defined.');\n  return Promise.resolve(false);\n}\n\n/**\n * Returns true if Sentry has been properly initialized.\n */\nfunction isInitialized() {\n  return !!getClient();\n}\n\n/** If the SDK is initialized & enabled. */\nfunction isEnabled() {\n  const client = getClient();\n  return client?.getOptions().enabled !== false && !!client?.getTransport();\n}\n\n/**\n * Add an event processor.\n * This will be added to the current isolation scope, ensuring any event that is processed in the current execution\n * context will have the processor applied.\n */\nfunction addEventProcessor(callback) {\n  getIsolationScope().addEventProcessor(callback);\n}\n\n/**\n * Start a session on the current isolation scope.\n *\n * @param context (optional) additional properties to be applied to the returned session object\n *\n * @returns the new active session\n */\nfunction startSession(context) {\n  const isolationScope = getIsolationScope();\n\n  const { user } = getCombinedScopeData(isolationScope, getCurrentScope());\n\n  // Will fetch userAgent if called from browser sdk\n  const { userAgent } = GLOBAL_OBJ.navigator || {};\n\n  const session = makeSession({\n    user,\n    ...(userAgent && { userAgent }),\n    ...context,\n  });\n\n  // End existing session if there's one\n  const currentSession = isolationScope.getSession();\n  if (currentSession?.status === 'ok') {\n    updateSession(currentSession, { status: 'exited' });\n  }\n\n  endSession();\n\n  // Afterwards we set the new session on the scope\n  isolationScope.setSession(session);\n\n  return session;\n}\n\n/**\n * End the session on the current isolation scope.\n */\nfunction endSession() {\n  const isolationScope = getIsolationScope();\n  const currentScope = getCurrentScope();\n\n  const session = currentScope.getSession() || isolationScope.getSession();\n  if (session) {\n    closeSession(session);\n  }\n  _sendSessionUpdate();\n\n  // the session is over; take it off of the scope\n  isolationScope.setSession();\n}\n\n/**\n * Sends the current Session on the scope\n */\nfunction _sendSessionUpdate() {\n  const isolationScope = getIsolationScope();\n  const client = getClient();\n  const session = isolationScope.getSession();\n  if (session && client) {\n    client.captureSession(session);\n  }\n}\n\n/**\n * Sends the current session on the scope to Sentry\n *\n * @param end If set the session will be marked as exited and removed from the scope.\n *            Defaults to `false`.\n */\nfunction captureSession(end = false) {\n  // both send the update and pull the session from the scope\n  if (end) {\n    endSession();\n    return;\n  }\n\n  // only send the update\n  _sendSessionUpdate();\n}\n\nexport { addEventProcessor, captureCheckIn, captureEvent, captureException, captureMessage, captureSession, close, endSession, flush, isEnabled, isInitialized, lastEventId, setContext, setConversationId, setExtra, setExtras, setTag, setTags, setUser, startSession, withMonitor };\n//# sourceMappingURL=exports.js.map\n","/**\n * @license React\n * react.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\nvar REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n  REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n  REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n  REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n  REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\n  REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n  REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n  REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n  REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n  REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n  REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n  REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nfunction getIteratorFn(maybeIterable) {\n  if (null === maybeIterable || \"object\" !== typeof maybeIterable) return null;\n  maybeIterable =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[\"@@iterator\"];\n  return \"function\" === typeof maybeIterable ? maybeIterable : null;\n}\nvar ReactNoopUpdateQueue = {\n    isMounted: function () {\n      return !1;\n    },\n    enqueueForceUpdate: function () {},\n    enqueueReplaceState: function () {},\n    enqueueSetState: function () {}\n  },\n  assign = Object.assign,\n  emptyObject = {};\nfunction Component(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  this.refs = emptyObject;\n  this.updater = updater || ReactNoopUpdateQueue;\n}\nComponent.prototype.isReactComponent = {};\nComponent.prototype.setState = function (partialState, callback) {\n  if (\n    \"object\" !== typeof partialState &&\n    \"function\" !== typeof partialState &&\n    null != partialState\n  )\n    throw Error(\n      \"takes an object of state variables to update or a function which returns an object of state variables.\"\n    );\n  this.updater.enqueueSetState(this, partialState, callback, \"setState\");\n};\nComponent.prototype.forceUpdate = function (callback) {\n  this.updater.enqueueForceUpdate(this, callback, \"forceUpdate\");\n};\nfunction ComponentDummy() {}\nComponentDummy.prototype = Component.prototype;\nfunction PureComponent(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  this.refs = emptyObject;\n  this.updater = updater || ReactNoopUpdateQueue;\n}\nvar pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());\npureComponentPrototype.constructor = PureComponent;\nassign(pureComponentPrototype, Component.prototype);\npureComponentPrototype.isPureReactComponent = !0;\nvar isArrayImpl = Array.isArray;\nfunction noop() {}\nvar ReactSharedInternals = { H: null, A: null, T: null, S: null },\n  hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction ReactElement(type, key, props) {\n  var refProp = props.ref;\n  return {\n    $$typeof: REACT_ELEMENT_TYPE,\n    type: type,\n    key: key,\n    ref: void 0 !== refProp ? refProp : null,\n    props: props\n  };\n}\nfunction cloneAndReplaceKey(oldElement, newKey) {\n  return ReactElement(oldElement.type, newKey, oldElement.props);\n}\nfunction isValidElement(object) {\n  return (\n    \"object\" === typeof object &&\n    null !== object &&\n    object.$$typeof === REACT_ELEMENT_TYPE\n  );\n}\nfunction escape(key) {\n  var escaperLookup = { \"=\": \"=0\", \":\": \"=2\" };\n  return (\n    \"$\" +\n    key.replace(/[=:]/g, function (match) {\n      return escaperLookup[match];\n    })\n  );\n}\nvar userProvidedKeyEscapeRegex = /\\/+/g;\nfunction getElementKey(element, index) {\n  return \"object\" === typeof element && null !== element && null != element.key\n    ? escape(\"\" + element.key)\n    : index.toString(36);\n}\nfunction resolveThenable(thenable) {\n  switch (thenable.status) {\n    case \"fulfilled\":\n      return thenable.value;\n    case \"rejected\":\n      throw thenable.reason;\n    default:\n      switch (\n        (\"string\" === typeof thenable.status\n          ? thenable.then(noop, noop)\n          : ((thenable.status = \"pending\"),\n            thenable.then(\n              function (fulfilledValue) {\n                \"pending\" === thenable.status &&\n                  ((thenable.status = \"fulfilled\"),\n                  (thenable.value = fulfilledValue));\n              },\n              function (error) {\n                \"pending\" === thenable.status &&\n                  ((thenable.status = \"rejected\"), (thenable.reason = error));\n              }\n            )),\n        thenable.status)\n      ) {\n        case \"fulfilled\":\n          return thenable.value;\n        case \"rejected\":\n          throw thenable.reason;\n      }\n  }\n  throw thenable;\n}\nfunction mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n  var type = typeof children;\n  if (\"undefined\" === type || \"boolean\" === type) children = null;\n  var invokeCallback = !1;\n  if (null === children) invokeCallback = !0;\n  else\n    switch (type) {\n      case \"bigint\":\n      case \"string\":\n      case \"number\":\n        invokeCallback = !0;\n        break;\n      case \"object\":\n        switch (children.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = !0;\n            break;\n          case REACT_LAZY_TYPE:\n            return (\n              (invokeCallback = children._init),\n              mapIntoArray(\n                invokeCallback(children._payload),\n                array,\n                escapedPrefix,\n                nameSoFar,\n                callback\n              )\n            );\n        }\n    }\n  if (invokeCallback)\n    return (\n      (callback = callback(children)),\n      (invokeCallback =\n        \"\" === nameSoFar ? \".\" + getElementKey(children, 0) : nameSoFar),\n      isArrayImpl(callback)\n        ? ((escapedPrefix = \"\"),\n          null != invokeCallback &&\n            (escapedPrefix =\n              invokeCallback.replace(userProvidedKeyEscapeRegex, \"$&/\") + \"/\"),\n          mapIntoArray(callback, array, escapedPrefix, \"\", function (c) {\n            return c;\n          }))\n        : null != callback &&\n          (isValidElement(callback) &&\n            (callback = cloneAndReplaceKey(\n              callback,\n              escapedPrefix +\n                (null == callback.key ||\n                (children && children.key === callback.key)\n                  ? \"\"\n                  : (\"\" + callback.key).replace(\n                      userProvidedKeyEscapeRegex,\n                      \"$&/\"\n                    ) + \"/\") +\n                invokeCallback\n            )),\n          array.push(callback)),\n      1\n    );\n  invokeCallback = 0;\n  var nextNamePrefix = \"\" === nameSoFar ? \".\" : nameSoFar + \":\";\n  if (isArrayImpl(children))\n    for (var i = 0; i < children.length; i++)\n      (nameSoFar = children[i]),\n        (type = nextNamePrefix + getElementKey(nameSoFar, i)),\n        (invokeCallback += mapIntoArray(\n          nameSoFar,\n          array,\n          escapedPrefix,\n          type,\n          callback\n        ));\n  else if (((i = getIteratorFn(children)), \"function\" === typeof i))\n    for (\n      children = i.call(children), i = 0;\n      !(nameSoFar = children.next()).done;\n\n    )\n      (nameSoFar = nameSoFar.value),\n        (type = nextNamePrefix + getElementKey(nameSoFar, i++)),\n        (invokeCallback += mapIntoArray(\n          nameSoFar,\n          array,\n          escapedPrefix,\n          type,\n          callback\n        ));\n  else if (\"object\" === type) {\n    if (\"function\" === typeof children.then)\n      return mapIntoArray(\n        resolveThenable(children),\n        array,\n        escapedPrefix,\n        nameSoFar,\n        callback\n      );\n    array = String(children);\n    throw Error(\n      \"Objects are not valid as a React child (found: \" +\n        (\"[object Object]\" === array\n          ? \"object with keys {\" + Object.keys(children).join(\", \") + \"}\"\n          : array) +\n        \"). If you meant to render a collection of children, use an array instead.\"\n    );\n  }\n  return invokeCallback;\n}\nfunction mapChildren(children, func, context) {\n  if (null == children) return children;\n  var result = [],\n    count = 0;\n  mapIntoArray(children, result, \"\", \"\", function (child) {\n    return func.call(context, child, count++);\n  });\n  return result;\n}\nfunction lazyInitializer(payload) {\n  if (-1 === payload._status) {\n    var ctor = payload._result;\n    ctor = ctor();\n    ctor.then(\n      function (moduleObject) {\n        if (0 === payload._status || -1 === payload._status)\n          (payload._status = 1), (payload._result = moduleObject);\n      },\n      function (error) {\n        if (0 === payload._status || -1 === payload._status)\n          (payload._status = 2), (payload._result = error);\n      }\n    );\n    -1 === payload._status && ((payload._status = 0), (payload._result = ctor));\n  }\n  if (1 === payload._status) return payload._result.default;\n  throw payload._result;\n}\nvar reportGlobalError =\n    \"function\" === typeof reportError\n      ? reportError\n      : function (error) {\n          if (\n            \"object\" === typeof window &&\n            \"function\" === typeof window.ErrorEvent\n          ) {\n            var event = new window.ErrorEvent(\"error\", {\n              bubbles: !0,\n              cancelable: !0,\n              message:\n                \"object\" === typeof error &&\n                null !== error &&\n                \"string\" === typeof error.message\n                  ? String(error.message)\n                  : String(error),\n              error: error\n            });\n            if (!window.dispatchEvent(event)) return;\n          } else if (\n            \"object\" === typeof process &&\n            \"function\" === typeof process.emit\n          ) {\n            process.emit(\"uncaughtException\", error);\n            return;\n          }\n          console.error(error);\n        },\n  Children = {\n    map: mapChildren,\n    forEach: function (children, forEachFunc, forEachContext) {\n      mapChildren(\n        children,\n        function () {\n          forEachFunc.apply(this, arguments);\n        },\n        forEachContext\n      );\n    },\n    count: function (children) {\n      var n = 0;\n      mapChildren(children, function () {\n        n++;\n      });\n      return n;\n    },\n    toArray: function (children) {\n      return (\n        mapChildren(children, function (child) {\n          return child;\n        }) || []\n      );\n    },\n    only: function (children) {\n      if (!isValidElement(children))\n        throw Error(\n          \"React.Children.only expected to receive a single React element child.\"\n        );\n      return children;\n    }\n  };\nexports.Activity = REACT_ACTIVITY_TYPE;\nexports.Children = Children;\nexports.Component = Component;\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.Profiler = REACT_PROFILER_TYPE;\nexports.PureComponent = PureComponent;\nexports.StrictMode = REACT_STRICT_MODE_TYPE;\nexports.Suspense = REACT_SUSPENSE_TYPE;\nexports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =\n  ReactSharedInternals;\nexports.__COMPILER_RUNTIME = {\n  __proto__: null,\n  c: function (size) {\n    return ReactSharedInternals.H.useMemoCache(size);\n  }\n};\nexports.cache = function (fn) {\n  return function () {\n    return fn.apply(null, arguments);\n  };\n};\nexports.cacheSignal = function () {\n  return null;\n};\nexports.cloneElement = function (element, config, children) {\n  if (null === element || void 0 === element)\n    throw Error(\n      \"The argument must be a React element, but you passed \" + element + \".\"\n    );\n  var props = assign({}, element.props),\n    key = element.key;\n  if (null != config)\n    for (propName in (void 0 !== config.key && (key = \"\" + config.key), config))\n      !hasOwnProperty.call(config, propName) ||\n        \"key\" === propName ||\n        \"__self\" === propName ||\n        \"__source\" === propName ||\n        (\"ref\" === propName && void 0 === config.ref) ||\n        (props[propName] = config[propName]);\n  var propName = arguments.length - 2;\n  if (1 === propName) props.children = children;\n  else if (1 < propName) {\n    for (var childArray = Array(propName), i = 0; i < propName; i++)\n      childArray[i] = arguments[i + 2];\n    props.children = childArray;\n  }\n  return ReactElement(element.type, key, props);\n};\nexports.createContext = function (defaultValue) {\n  defaultValue = {\n    $$typeof: REACT_CONTEXT_TYPE,\n    _currentValue: defaultValue,\n    _currentValue2: defaultValue,\n    _threadCount: 0,\n    Provider: null,\n    Consumer: null\n  };\n  defaultValue.Provider = defaultValue;\n  defaultValue.Consumer = {\n    $$typeof: REACT_CONSUMER_TYPE,\n    _context: defaultValue\n  };\n  return defaultValue;\n};\nexports.createElement = function (type, config, children) {\n  var propName,\n    props = {},\n    key = null;\n  if (null != config)\n    for (propName in (void 0 !== config.key && (key = \"\" + config.key), config))\n      hasOwnProperty.call(config, propName) &&\n        \"key\" !== propName &&\n        \"__self\" !== propName &&\n        \"__source\" !== propName &&\n        (props[propName] = config[propName]);\n  var childrenLength = arguments.length - 2;\n  if (1 === childrenLength) props.children = children;\n  else if (1 < childrenLength) {\n    for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)\n      childArray[i] = arguments[i + 2];\n    props.children = childArray;\n  }\n  if (type && type.defaultProps)\n    for (propName in ((childrenLength = type.defaultProps), childrenLength))\n      void 0 === props[propName] &&\n        (props[propName] = childrenLength[propName]);\n  return ReactElement(type, key, props);\n};\nexports.createRef = function () {\n  return { current: null };\n};\nexports.forwardRef = function (render) {\n  return { $$typeof: REACT_FORWARD_REF_TYPE, render: render };\n};\nexports.isValidElement = isValidElement;\nexports.lazy = function (ctor) {\n  return {\n    $$typeof: REACT_LAZY_TYPE,\n    _payload: { _status: -1, _result: ctor },\n    _init: lazyInitializer\n  };\n};\nexports.memo = function (type, compare) {\n  return {\n    $$typeof: REACT_MEMO_TYPE,\n    type: type,\n    compare: void 0 === compare ? null : compare\n  };\n};\nexports.startTransition = function (scope) {\n  var prevTransition = ReactSharedInternals.T,\n    currentTransition = {};\n  ReactSharedInternals.T = currentTransition;\n  try {\n    var returnValue = scope(),\n      onStartTransitionFinish = ReactSharedInternals.S;\n    null !== onStartTransitionFinish &&\n      onStartTransitionFinish(currentTransition, returnValue);\n    \"object\" === typeof returnValue &&\n      null !== returnValue &&\n      \"function\" === typeof returnValue.then &&\n      returnValue.then(noop, reportGlobalError);\n  } catch (error) {\n    reportGlobalError(error);\n  } finally {\n    null !== prevTransition &&\n      null !== currentTransition.types &&\n      (prevTransition.types = currentTransition.types),\n      (ReactSharedInternals.T = prevTransition);\n  }\n};\nexports.unstable_useCacheRefresh = function () {\n  return ReactSharedInternals.H.useCacheRefresh();\n};\nexports.use = function (usable) {\n  return ReactSharedInternals.H.use(usable);\n};\nexports.useActionState = function (action, initialState, permalink) {\n  return ReactSharedInternals.H.useActionState(action, initialState, permalink);\n};\nexports.useCallback = function (callback, deps) {\n  return ReactSharedInternals.H.useCallback(callback, deps);\n};\nexports.useContext = function (Context) {\n  return ReactSharedInternals.H.useContext(Context);\n};\nexports.useDebugValue = function () {};\nexports.useDeferredValue = function (value, initialValue) {\n  return ReactSharedInternals.H.useDeferredValue(value, initialValue);\n};\nexports.useEffect = function (create, deps) {\n  return ReactSharedInternals.H.useEffect(create, deps);\n};\nexports.useEffectEvent = function (callback) {\n  return ReactSharedInternals.H.useEffectEvent(callback);\n};\nexports.useId = function () {\n  return ReactSharedInternals.H.useId();\n};\nexports.useImperativeHandle = function (ref, create, deps) {\n  return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);\n};\nexports.useInsertionEffect = function (create, deps) {\n  return ReactSharedInternals.H.useInsertionEffect(create, deps);\n};\nexports.useLayoutEffect = function (create, deps) {\n  return ReactSharedInternals.H.useLayoutEffect(create, deps);\n};\nexports.useMemo = function (create, deps) {\n  return ReactSharedInternals.H.useMemo(create, deps);\n};\nexports.useOptimistic = function (passthrough, reducer) {\n  return ReactSharedInternals.H.useOptimistic(passthrough, reducer);\n};\nexports.useReducer = function (reducer, initialArg, init) {\n  return ReactSharedInternals.H.useReducer(reducer, initialArg, init);\n};\nexports.useRef = function (initialValue) {\n  return ReactSharedInternals.H.useRef(initialValue);\n};\nexports.useState = function (initialState) {\n  return ReactSharedInternals.H.useState(initialState);\n};\nexports.useSyncExternalStore = function (\n  subscribe,\n  getSnapshot,\n  getServerSnapshot\n) {\n  return ReactSharedInternals.H.useSyncExternalStore(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot\n  );\n};\nexports.useTransition = function () {\n  return ReactSharedInternals.H.useTransition();\n};\nexports.version = \"19.2.1\";\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react.production.js');\n} else {\n  module.exports = require('./cjs/react.development.js');\n}\n"],"names":["DEBUG_BUILD","GLOBAL_OBJ","SDK_VERSION","getMainCarrier","getSentryCarrier","carrier","__SENTRY__","getGlobalSingleton","name","creator","obj","PREFIX","originalConsoleMethods","consoleSandbox","callback","console","wrappedFuncs","wrappedLevels","level","originalConsoleMethod","enable","_getLoggerSettings","disable","isEnabled","log","args","_maybeLog","warn","error","debug","objectToString","isBuiltin","wat","className","isPlainObject","isThenable","addNonEnumerableProperty","value","RESOLVED_RUNNER","withRandomSafeContext","cb","sym","globalWithSymbol","safeMathRandom","safeDateNow","truncate","str","max","getCrypto","gbl","emptyUuid","getRandomByte","uuid4","crypto","c","ONE_SECOND_IN_MS","dateTimestampInSeconds","createUnixTimestampInSecondsFunc","performance","timeOrigin","_cachedTimestampInSeconds","timestampInSeconds","updateSession","session","context","duration","merge","initialObj","mergeObj","levels","output","key","generateTraceId","SCOPE_SPAN_FIELD","_setSpanForScope","scope","span","_getSpanForScope","DEFAULT_MAX_BREADCRUMBS","Scope","newScope","client","lastEventId","user","conversationId","tags","newAttributes","extras","extra","fingerprint","captureContext","scopeToMerge","scopeInstance","attributes","contexts","propagationContext","breadcrumb","maxBreadcrumbs","maxCrumbs","mergedBreadcrumb","attachment","newData","exception","hint","eventId","syntheticException","message","event","getDefaultCurrentScope","getDefaultIsolationScope","AsyncContextStack","isolationScope","assignedScope","assignedIsolationScope","maybePromiseResult","e","res","getAsyncContextStack","registry","sentry","withScope","withSetScope","stack","withIsolationScope","getStackAsyncContextStrategy","_isolationScope","getAsyncContextStrategy","getCurrentScope","parseEventHintOrCaptureContext","hintIsScopeOrFunction","hintIsScopeContext","captureContextKeys","captureException","REACT_ELEMENT_TYPE","REACT_PORTAL_TYPE","REACT_FRAGMENT_TYPE","REACT_STRICT_MODE_TYPE","REACT_PROFILER_TYPE","REACT_CONSUMER_TYPE","REACT_CONTEXT_TYPE","REACT_FORWARD_REF_TYPE","REACT_SUSPENSE_TYPE","REACT_MEMO_TYPE","REACT_LAZY_TYPE","REACT_ACTIVITY_TYPE","MAYBE_ITERATOR_SYMBOL","getIteratorFn","maybeIterable","ReactNoopUpdateQueue","assign","emptyObject","Component","props","updater","partialState","ComponentDummy","PureComponent","pureComponentPrototype","isArrayImpl","noop","ReactSharedInternals","hasOwnProperty","ReactElement","type","refProp","cloneAndReplaceKey","oldElement","newKey","isValidElement","object","escape","escaperLookup","match","userProvidedKeyEscapeRegex","getElementKey","element","index","resolveThenable","thenable","fulfilledValue","mapIntoArray","children","array","escapedPrefix","nameSoFar","invokeCallback","nextNamePrefix","i","mapChildren","func","result","count","child","lazyInitializer","payload","ctor","moduleObject","reportGlobalError","Children","forEachFunc","forEachContext","n","react_production","size","fn","config","propName","childArray","defaultValue","childrenLength","render","compare","prevTransition","currentTransition","returnValue","onStartTransitionFinish","usable","action","initialState","permalink","deps","Context","initialValue","create","ref","passthrough","reducer","initialArg","init","subscribe","getSnapshot","getServerSnapshot","reactModule","require$$0"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]}